

## `Programov√°n√≠` 1 pro matematiky

# 3. cviƒçen√≠, 15-10-2024



**Obsah**:

0. Farn√≠ oznamy
1. Opakov√°n√≠
2. Dom√°c√≠ √∫koly
3. Resty z minula
4. Seznamy



### Farn√≠ oznamy

1. **Materi√°ly k p≈ôedn√°≈°k√°m** najdete v GitHub repozit√°≈ôi https://github.com/PKvasnick/Programovani-1. Najdete tam tak√© k√≥d ke cviƒçen√≠m.
2. **Dom√°c√≠ √∫koly** Minul√Ω t√Ωden jste dostali 3 p≈ô√≠klady a nashrom√°≈ædilo se docela hodnƒõ ≈ôesen√≠. 
   * Individu√°lnƒõ se vyskytly probl√©my s ReCodExem, zejm√©na  s pochopen√≠m toho, ≈æe v≈°e, co nap√≠≈°ete na v√Ωstup, pova≈æuje ReCodEx za souƒç√°st va≈°eho ≈ôe≈°en√≠. 
     * D≈Økladnƒõ ƒçtƒõte zad√°n√≠
     * Napi≈°te na v√Ωstup jenom odpovƒõƒè v po≈æadovan√©m tvaru a nic v√≠c. 
   * Vyskytlo se docela dost √∫loh, pou≈æ√≠vaj√≠c√≠ch pokroƒçilej≈°√≠ struktury Pythonu, nap≈ô. funkce.  
     * v principu nenam√≠t√°m, ale myslete pros√≠m na spolu≈æ√°ky, kte≈ô√≠ stejn√Ω √∫kkol vy≈ôe≈°√≠ za pomoci jednodu≈°≈°√≠ch prost≈ôedk≈Ø. Je v√°≈° k√≥d natolik elegantn√≠, ≈æe to omlouv√° pou≈æ√≠v√°n√≠ tƒõ≈æk√Ωch zbran√≠?

K dom√°c√≠m √∫kol√∫m a ReCodExu se je≈°tƒõ ob≈°irnƒõji vr√°t√≠m.

------

## Opakov√°n√≠

... a co se poslednƒõ neve≈°lo:

**`if-elif-else`:**

```{python}
if podm√≠nka1:
   p≈ô√≠kazy1
elif podm√≠nka2:
   p≈ô√≠kazy2
else:		
   p≈ô√≠kazy3
```
- [ ] **Pr√°zdn√Ω p≈ô√≠kaz `pass`**

##### P≈ô√≠kaz `match case`

```
match term:
    case pattern-1:
         action-1
    case pattern-2:
         action-2
    case pattern-3:
         action-3
    case _:
        action-default
```

Tento p≈ô√≠kaz n√°m umo≈æ≈àuje nahradit strukturu `if-elif-else` v p≈ô√≠padech, kdy vyb√≠r√°me z vƒõt≈°√≠ho mno≈æstv√≠ voleb:

Nam√≠sto 

```python
lang = input("What's the programming language you want to learn? ")

def switch(lang):
	if lang == "JavaScript":
    	print("You can become a web developer.")
	elif lang == "PHP":
    	print("You can become a backend developer.")
	elif lang == "Python":
    	print("You can become a Data Scientist")
	elif lang == "Solidity":
    	print("You can become a Blockchain developer.")
	elif lang == "Java":
    	print("You can become a mobile app developer")
	else:
    	print("The language doesn't matter, what matters is solving problems.")

# 2 ≈ô√°dky mezi definic√≠ funkce a ƒç√≠mkoli co n√°sleduje        
print(switch("JavaScript"))   
print(switch("PHP"))   
print(switch("Java"))  

"""
Output: 
You can become a web developer.
You can become a backend developer.
You can become a mobile app developer
"""

```

m≈Ø≈æeme ps√°t

```python
lang = input("What's the programming language you want to learn? ")

match lang:
    case "JavaScript":
        print("You can become a web developer.")

    case "Python":
        print("You can become a Data Scientist")

    case "PHP":
        print("You can become a backend developer")

    case "Solidity":
        print("You can become a Blockchain developer")

    case "Java":
        print("You can become a mobile app developer")
    case _:
        print("The language doesn't matter, what matters is solving problems.")
```

Podstatn√° v√Ωhoda `match case`  je, ≈æe um√≠ p≈ôi≈ôazovat slo≈æitƒõj≈°√≠ vzory:

```python
point = (1, 2)

match point:
    case (0, 0):
        result = "Origin"
    case (x, 0):
        result = f"X-axis at {x}"
    case (0, y):
        result = f"Y-axis at {y}"
    case (x, y):
        result = f"Point at {x}, {y}"
```

V Pythonu existuj√≠ je≈°tƒõ jin√© zp≈Øsoby implementace mnohon√°sobn√©ho vƒõtven√≠, nap≈ô. pomoc√≠ slovn√≠ku - to je velice typick√Ω Pythonsk√Ω postup:

```python
messages = {
    "JavaScript":"You can become a web developer.", 	"Python": "You can become a Data Scientist", 
    "PHP": "You can become a backend developer"
    ...
}
lang = input("What's the programming language you want to learn? ")
print(messages[lang])
```

---

**Cyklus `while`:**

```{python}
while podm√≠nka:
   p≈ô√≠kazy
```
P≈ô√≠kazy pro kontrolu bƒõhu cyklu:

`break` - v tomto m√≠stƒõ opustit cyklus a pokraƒçovat p≈ô√≠kazem, n√°sleduj√≠c√≠m za cyklem

`continue` - v tomto m√≠stƒõ p≈ôej√≠t na dal≈°√≠ iteraci cyklu (tedy na testov√°n√≠ podm√≠nky)

Vƒõtev `else`:

```{python}
while podm√≠nka:
   p≈ô√≠kazy
else
   p≈ô√≠kazy-jen-jestli-probƒõhl-cel√Ω-cyklus
```

**P≈ô√≠kaz print** 

```
print(a, b, c, ..., sep=<≈ôetƒõzec>, end=<≈ôetƒõzec>)
```

Default: `sep = " "`, `end = "\n"`

**f-≈ôetƒõzce**

```python
a = 5
b = 10.27
s = f"M√°m {a} tyƒç√≠ s d√©lkou {b:.1f}m"
print(s)
---------
M√°m 5 tyƒç√≠ s d√©lkou 10.3m
```

---

## Dom√°c√≠ √∫koly

#### ƒåistota a ƒçitelnost k√≥du

Porovnejte pros√≠m tyto dva k√≥dy. Oba jsou spr√°vn√© a dƒõlaj√≠ spr√°vnƒõ to, co maj√≠.  

Tento k√≥d, vƒçetnƒõ n√°zv≈Ø identifik√°tor≈Ø, vyvinulo nƒõkolik z v√°s:

```python
a=int(input())
b=int(input())
if a>b:
    print("P")
elif a<b:
    print("O")
else:
    print("R")
```

Porovnejte ho pros√≠m s t√≠mto k√≥dem (to je tak√© ≈ôe≈°en√≠, poch√°zej√≠c√≠ od jednoho z v√°s):

```python
cislo_princezny = int(input())
cislo_obra = int(input())

if cislo_princezny > cislo_obra:
    print("P")
elif cislo_princezny < cislo_obra:
    print("O")
else:
    print("R")
```

Probl√©m s prvn√≠m k√≥dem je, ≈æe si nƒõkde mus√≠te zapamatovat p≈ôi≈ôazen√≠ a‚Üíƒç√≠slo od princezny, a‚Üíƒç√≠slo od obra. Pak prvn√≠mu k√≥du rozum√≠te stejnƒõ dob≈ôe jako druh√©mu, ale v hlavƒõ mus√≠te dr≈æet n√°hodnou informaci, pot≈ôebnou k pochopen√≠ k√≥du. 

K√≥d, kter√Ω m√° kr√°tk√© n√°zvy promƒõnn√Ωch, nen√≠ v nijak√©m smyslu v√Ωkonnƒõj≈°√≠ nebo √∫spornƒõj≈°√≠ ne≈æ k√≥d s dlouh√Ωmi promƒõnn√Ωmi. Na druhou stranu, k√≥d s p≈ô√≠li≈° dlouh√Ωmi identifik√°tory je prostƒõ v√≠ce textu a m≈Ø≈æe se h≈Ø≈ô ƒç√≠st. 

**Jm√©na objekt≈Ø v Pythonu:** Poƒç√°teƒçn√≠ p√≠smeno, pak kombinace velk√Ωch i mal√Ωch p√≠smen, ƒç√≠slic a podtr≈æ√≠tek. 

**Sna≈æte se pros√≠m pou≈æ√≠vat n√°zvy promƒõnn√Ωch, kter√© reflektuj√≠ jejich v√Ωznam. **

Je≈°tƒõ jeden probl√©m s prvn√≠m k√≥dem:

Python p≈ôedpisuje kolem bin√°rn√≠ch oper√°tor≈Ø **mezery**. V√Ωjimkou je p≈ôi≈ôazen√≠ pojmenovan√Ωch parametr≈Ø.  Mezi jm√©nem funkce a seznamem jej√≠ch parametr≈Ø v z√°vork√°ch mezera *nen√≠*. Mezery tak√© pat≈ô√≠ za ƒç√°rky, oddƒõluj√≠c√≠ prvky seznamu nebo n-tice.

Tedy

```python
a = b**2 + c**2
print("Petr", "Franta", "Josef", sep="-", end="konec\n")
n = int("3")
```

#### Prost≈ôedky Pythonu

Hodnƒõ z v√°s zn√° z Pythonu v√≠c, ne≈æ jsme zat√≠m probrali. P≈ôij√≠m√°m i ≈ôe≈°en√≠, kter√° pou≈æ√≠vaj√≠ pros≈•redky jazyka, kter√© jsme zat√≠m neprob√≠rali, 

- pokud to nen√≠ v rozporu s √∫ƒçelem zad√°n√≠ - tedy kdy≈æ m√°te sami naprogramovat nƒõco, na co existuje v Pythonu knihovn√≠ funkce - nap≈ô√≠klad budeme programovat GCD(a,b), zat√≠mco m√°me funkci `math.gcd()`, kter√° to udƒõl√° za v√°s, nebo kdy≈æ m√°te zjistit poƒçet ƒç√≠slic cel√©ho ƒç√≠sla bez pou≈æit√≠ zkratky `len(str(n))`.
- pokud to vede k ƒçist≈°√≠mu a efektivn√≠mu k√≥du

C√≠lem tohoto cviƒçen√≠ je nauƒçit v√°s ps√°t nejen spr√°vn√Ω, ale i ƒçist√Ω a dob≈ôe ƒçiteln√Ω k√≥d. Toho dos√°hnete i √∫ƒçeln√Ωm vyu≈æ√≠v√°n√≠m rozmanit√Ωch prost≈ôedk≈Ø jazyka.  

---

## Programujeme - pokraƒçov√°n√≠ od minula

### Test prvoƒç√≠sel

Chceme otestovat, zda je ƒç√≠slo $n$ ze vstupu prvoƒç√≠slo.

Metoda: U v≈°ech ƒç√≠sel $d<n$ provƒõ≈ô√≠m, zda jsou dƒõliteli $n$.

```{python}
#!/usr/bin/env python3

# Otestuje, zda ƒç√≠slo je prvoƒç√≠slem

n = int(input())
d = 2
mam_delitele = False

while d < n:
    if n%d == 0:
        print("ƒå√≠slo", n, "je dƒõliteln√©", d)
        mam_delitele = True
        break
    d += 1

if not mam_delitele:
    print("ƒå√≠slo", n, "je prvoƒç√≠slo")
```

To nen√≠ nijak zvl√°≈°≈• efektivn√≠ metoda, ale to n√°m nevad√≠, my jsme cel√≠ r√°di, ≈æe um√≠me napsat nƒõco, co v z√°sadƒõ funguje. 

Pojƒème opatrnƒõ vylep≈°ovat. Z√°sadn√≠ vylep≈°en√≠ k√≥du by bylo, kdybychom "nah√Ω" cyklus `while` umƒõli cel√Ω zapouzd≈ôit do jedin√©ho p≈ô√≠kazu. 

üòé _Pokroƒçil√© kolegy popros√≠m o tvar onoho jedin√©ho p≈ô√≠kazu._

Asi prvn√≠ vƒõc, kter√° n√°m vad√≠, je stavov√° promƒõnn√° `mam_delitele`. A t√© se v prvn√≠m kroku zbav√≠me za pou≈æit√≠ vƒõtve `else`:

```{python}
#!/usr/bin/env python3

# Otestuje, zda ƒç√≠slo je prvoƒç√≠slem (2. pokus)

n = int(input())
d = 2

while d < n:
    if n%d == 0:
        print("ƒå√≠slo", n, "je dƒõliteln√©", d)
        break
    d += 1
else:
    print("ƒå√≠slo", n, "je prvoƒç√≠slo")
```

Jak bychom mohli d√°l vylep≈°it n√°≈° test?

Pop≈ôem√Ω≈°l√≠me, a zat√≠m vymysl√≠me, jak bychom vypsali v≈°echna provƒç√≠sla men≈°√≠ nebo rovn√° $n$. Nejjednodu≈°≈°√≠ metoda bude proj√≠t v≈°echna ƒç√≠sla od 2 do $n$, u ka≈æd√©ho rozhodnout, zda je prvoƒç√≠slem, a jestli ano, vypsat ho. 

```python
#!/usr/bin/env python3
# Vyp√≠≈°e v≈°echna prvoƒç√≠sla od 1 do n

n = int(input())

x = 2
while x <= n:
    d = 2
    while d < x:
        if x%d == 0:
            break
        d += 1
    else:
        print(x)

    x += 1

```

Optimalizace je v tomto p≈ô√≠padƒõ je≈°tƒõ v√≠ce nasnadƒõ, jenom≈æe si zat√≠m neum√≠me pamatovat vƒõci - nap≈ô√≠klad v≈°echny prvoƒç√≠sla, kter√© jsme dosud nalezli.

üòé _Pokroƒçil√© kolegy_ popros√≠m o optimalizovan√Ω algoritmus, nap≈ô. Erastothenovo s√≠to. 

-----

#### Souƒçet posloupnosti ƒç√≠sel

```python
#!/usr/bin/env python3

# Naƒçteme ze vstupu posloupnost ƒç√≠sel, ukonƒçenou -1.
# Vyp√≠≈°eme jejich souƒçet. 

s = 0
while True:
    n = int(input())
    if n == -1:
        break
    s += n
print(s)
```

Proƒç nem≈Ø≈æeme na konci jenom stisknout Enter a nezadat nic?

üòé _Pokroƒçil√© kolegy popros√≠m_

- o variantu se stiskem Enter 
- a o vyps√°n√≠ aritmetick√©ho pr≈Ømƒõru a standardn√≠ odchylky._

**Mro≈æ√≠ oper√°tor**

```python
>>> a = (b := 10)**2
>>> a
100
>>> b
10
>>> 
```

P≈ôi≈ôazen√≠, kter√© vrac√≠ hodnotu. *Pou≈æ√≠vat umƒõ≈ôenƒõ.* 

### Euklid≈Øv algoritmus

Z√°kladn√≠ verze s odeƒç√≠t√°n√≠m: $x>y: \gcd(x,y) = \gcd(x-y,y)$

```python
#!/usr/bin/env python3
# Nejvƒõt≈°√≠ spoleƒçn√Ω dƒõlitel: Euklid≈Øv algoritmus s odƒç√≠t√°n√≠m

x = int(input())
y = int(input())

while x != y:
    if x > y:
        x -= y
    else:
        y -= x

print(x)

```

Lad√≠c√≠ v√Ωpis: Pokud chceme vidƒõt, jak si vedou ƒç√≠sla x a y v cyklu while, p≈ôid√°me za r√°dek s `while` p≈ô√≠kaz

```python
print(f"{x=} {y=}")
```

Pokud je jedno z ƒç√≠sel o hodnƒõ men≈°√≠ ne≈æ druh√©, mo≈æn√° budeme opakovanƒõ odeƒç√≠tat, a to n√°s spomaluje (n√°roƒçnost algoritmu je line√°rn√≠ v n). Je proto lep≈°√≠ v jednom kroku odeƒç√≠tat kolikr√°t to jde: _odeƒç√≠t√°n√≠ nahrad√≠me operac√≠ modulo_:

```python
#!/usr/bin/env python3
# Nejvƒõt≈°√≠ spoleƒçn√Ω dƒõlitel: Euklid≈Øv algoritmus s modulem

x = int(input())
y = int(input())

while x > 0 and y > 0:
    if x > y:
        x %= y
    else:
        y %= x

if x > 0:
    print(x)
else:
    print(y)
```

Proto≈æe `x % y < y`, po ka≈æd√© operaci modulo v√≠me, jak√° je vz√°jemn√° velikost x a y. K√≥d tedy m≈Ø≈æeme v√Ωraznƒõ zdokonalit:

```python
#!/usr/bin/env python3
# Nejvƒõt≈°√≠ spoleƒçn√Ω dƒõlitel: Euklid≈Øv algoritmus s p√°r triky nav√≠c

x = int(input())
y = int(input())

while y > 0:
    x, y = y, x%y

print(x)
```

Tady si v≈°imneme p≈ôi≈ôazen√≠ `x, y = y, x%y`. Je to dvoj√≠ p≈ôi≈ôazen√≠, ale nelze jej rozdƒõlit na dvƒõ p≈ôi≈ôazen√≠ `x=y` a `y=x%y`, proto≈æe druh√© p≈ôi≈ôazen√≠ se po prvn√≠m zmƒõnilo na `y=y%y` a tedy y bude p≈ôi≈ôazena 0.  

1. M≈Ø≈æeme se pt√°t, proƒç to funguje (proto≈æe z dvojice na prav√© stranƒõ se p≈ôed p≈ôi≈ôazen√≠m vytvo≈ô√≠ nemƒõnn√° - konstantn√≠ dvojice - _tuple_ - a ten se p≈ôi p≈ôi≈ôazen√≠ "rozbal√≠" do x a y). 
2. Jak byste takov√©to p≈ôi≈ôazen√≠ rozepsali na jednoduch√° p≈ôi≈ôazen√≠, aby to fungovalo?

Toto je u≈æ celkem v√Ωkonn√Ω algoritmus, poƒçetn√≠ n√°roƒçnost je $\sim \log n$ Teƒè m≈Ø≈æeme dƒõlat v√≠c vƒõc√≠, nap≈ô√≠klad spoƒç√≠st Eulerovu funkci pro prvn√≠ch mili√≥n ƒç√≠sel a podobnƒõ. 

-----

## Seznamy

```python
>>> cisla = [1,2,3,4,5]
>>> type(cisla)
list
>>> cisla[0] # V Pythonu ƒç√≠slujeme od 0
1
>>> cisla[4] # tak≈æe posledn√≠ prvek je poƒçet prvk≈Ø - 1
5
>>> len(cisla) # poƒçet prvk≈Ø je len
5
>>> cisla[-1] # Indexov√°n√≠ je velmi flexibiln√≠
5
>>> cisla[1:3]
[2, 3]
>>> cisla[0:5]
[1, 2, 3, 4, 5]
>>> cisla[:3]
[1, 2, 3]
>>> cisla[3:]
[4, 5]
>>> cisla.append(6) # P≈ôid√°n√≠ nov√©ho prvku do seznamu
>>> cisla
[1, 2, 3, 4, 5, 6]
```

Seznamy m≈Ø≈æou obsahovat r≈Øzn√© vƒõci:

```python
zaci = ["Honza", "Jakub", "Franta"]
matice = [[1,2,3],[2,3,1]] # Neu≈æiteƒçn√° implementace matice
matice[0]
>>> [1,2,3]
matice[1][1] 
>>> 3
>>> [1,2] + [3,4] # aritmetika pro seznamy
[1, 2, 3, 4]
>>> [1,2]*3
[1, 2, 1, 2, 1, 2]
```

 ... ale tak√© polo≈æky r≈Øzn√©ho druhu:

```python
>>> lst = [1,"Peter",True]
>>> lst
[1, 'Peter', True]
>>> del lst[0]
>>> lst
['Peter', True]
>>> 
```

Pozor na kop√≠rov√°n√≠ seznam≈Ø:

```python
>>> a = ['jeden', 'dva', 'tri']
>>> b = a
>>> a[0] = 'jedna'
>>> b
['jedna', 'dva', 'tri']
>>> c = [[1,2]]*3
>>> c
[[1, 2], [1, 2], [1, 2]]
>>> c[0][0] = 0
>>> c
[[0, 2], [0, 2], [0, 2]]
```

Seznam um√≠me lehce set≈ô√≠dit nebo obr√°tit:

```python
>>> c = [2,4,1,3]
>>> sorted(c)
[1,2,3,4]
>>> reversed[c]
[3,1,4,2]
```

O t≈ô√≠dƒõn√≠ budeme mluvit na n√°sleduj√≠c√≠m cviƒçen√≠. 

#### Cyklus `for` 

```python
In [9]: cisla = [1,1,2,3,5,8]

In [10]: for cislo in cisla:
    ...:     print(cislo, end = "-")
    ...:
1-1-2-3-5-8-
```

ƒåasto chceme, aby cyklus prob√≠hal p≈ôes jednoduchou ƒç√≠selnou ≈ôadu, nap≈ô. $1,2,\dots,n$. Na generov√°n√≠ takov√Ωchto ≈ôad slou≈æ√≠ funkce `range`:

```python
>>> for i in range(5):
	print(i, end = ' ')
	
0 1 2 3 4 
```

`range` respektuje ƒç√≠slovac√≠ konvence Pythonu a podporuje je≈°tƒõ dal≈°√≠ argumenty: zaƒç√°tek sekvence a krok:

```python
>>> for i in range(2,10,3):
...     print(i)
...
2
5
8
```

Argumenty nemus√≠ b√Ωt kladn√° ƒç√≠sla, tak≈æe m≈Ø≈æeme lehko iterovat pozp√°tku:

```python
>>> for i in range(9,-1,-1):
---    print(i, end = ' ') 
---
9 8 7 6 5 4 3 2 1 0 >>> 
```

Tedy chceme-li iterovat pozp√°tku p≈ôes `range(n)`, pou≈æijeme `range(n-1,-1, -1)`.Abychom se nespletli, nab√≠z√≠ Python elegantnƒõj≈°√≠ ≈ôe≈°en√≠:

```python
>>> for i in reversed(range(5)):
	print(i, end = " ")

4 3 2 1 0 
```

a tuto funkci m≈Ø≈æeme pou≈æ√≠t na libovoln√Ω seznam:

```python
>>> cisla = ["jedna", "dvƒõ", "t≈ôi", "ƒçty≈ôi"]
>>> for cislo in reversed(cisla):
	print(cislo, end = " ")

ƒçty≈ôi t≈ôi dvƒõ jedna 
```

`range(n)` nen√≠ seznam, i kdy≈æ podporuje p≈ô√≠stup k pol≈æk√°m p≈ôes index:

```python
>>> range(10)
range(0, 10)
>>> type(range(10))
<class 'range'>
>>> range(10)[-1]
9
>>> list(range(10))
[0,1,2,3,4,5,6,7,8,9]
>>> [i for i in range(10)]
[0,1,2,3,4,5,6,7,8,9]
```

Tak√© `reversed/seznam)`nen√≠ seznam, ale reverzn√≠ iter√°tor:

```python
>>> reversed(cisla)
<list_reverseiterator object at 0x000002AE55D45370>
>>> [s for s in reversed(cisla)]
['ƒçty≈ôi', 't≈ôi', 'dvƒõ', 'jedna']
```

ale `sorted(seznam)` je seznam:

```python
>>> sorted(c)
[1, 2, 3, 4]
```

#### Fibonacciho ƒç√≠sla

$$
Fib(0) = 1,\\
Fib(1) = 1,\\
Fib(n) = Fib(n-1) + Fib(n-2),\quad = 2, 3, \dots
$$



*√öloha*: Vypi≈°te prvn√≠ch n Fibonacciho ƒç√≠sel. 

√övahy: 

- pot≈ôebujeme v≈Øbec seznam?

```python
# Vypsat prvnich n Fibonacciho cisel
n = int(input())
a = 1
print(a, end = ", ")
b = 1
print(b, end = ", ")
for k in range(3,n+1):
    b, a = b+a, b
    print(b, end = ", ")
```

- M≈Ø≈æeme zaƒç√≠t seznamem prvn√≠ch dvou ƒç√≠sel, a pak dopoƒç√≠t√°vat a p≈ôid√°vat na konec dal≈°√≠ ƒç√≠sla:

  ```python
  # Vypsat prvnich n Fibonacciho cisel
  n = int(input())
  fibs = [1,1]
  while len(fibs)<n:
  	fibs.append(fibs[-1] + fibs[-2])
  print(fibs)
  ```

- Nikdy nechcete alokovat pamƒõ≈• po mal√Ωch kousc√≠ch. Kdy≈æ p≈ôedem v√≠me d√©lku seznamu, je nejlep≈°√≠ z≈ô√≠dit ho cel√Ω a jenom ho naplnit. 

#### P≈ô√≠klad: Erastoth√©novo s√≠to

*√öloha*: Najdƒõte v≈°echna prvoƒç√≠sla men≈°√≠ nebo rovn√° n.

√övahy:

- Mus√≠me si nƒõjak pamatovat, kter√° ƒç√≠sla jsme u≈æ vy≈°ktrtli a kter√° n√°m je≈°tƒõ z≈Østala. 
- Jedno ≈ôe≈°en√≠ je, ≈æe vezmeme seznam v≈°ech ƒç√≠sel od 2 do n a budeme odstra≈àovat ty, kter√© nejsou prvoƒç√≠sly. To je ale pomal√© a v promƒõnliv√©m poli se ≈°patnƒõ iteruje - nen√≠ snadn√© urƒçit, kde pr√°vƒõ v poli jsme. 
- Lep≈°√≠ je vz√≠t seznam logick√Ωch hodnot. Index bude ƒç√≠slo, a hodnota bude oznaƒçovat, jestli jej zat√≠m pova≈æujeme za prvoƒç√≠slo anebo u≈æ ne. 

```python
# vypi≈° v≈°echna prvoƒç√≠sla men≈°√≠ nebo rovn√° n

n = int(input())

prvocisla = [True]*(n+1) # vƒçetnƒõ nuly a n
prvocisla[0] = False
prvocisla[1] = False
for i in range(2,n+1):
    if prvocisla[i]:
        for j in range(i*i, n+1, i):
            prvocisla[j]=False

print("Pocet: ", sum(prvocisla))
for i in range(n+1):
    if prvocisla[i]:
        print(i, end = ', ')
```

-----

#### Dal≈°√≠ √∫koly

- Najdƒõte ƒç√≠slo zapsan√© sam√Ωmi jedniƒçkami (v des√≠tkov√© soustavƒõ), kter√© je dƒõliteln√© zadan√Ωm K. Jak se vƒças zastavit, kdy≈æ neexistuje? 	
- Najdƒõte ƒç√≠slo mezi 1 a N s co nejv√≠ce dƒõliteli.	

**Dom√°c√≠ √∫koly na p≈ô√≠≈°t√≠ t√Ωden:**

* Na vstupu nez√°porn√© cel√© ƒç√≠slo, vypsat v bin√°rn√≠m tvaru.

- Na vstupu kladn√© cel√© n. Vypsat poƒçet Pytagorejsk√Ωch trojic s ƒç√≠sly men≈°√≠mi ne≈æ n.
- P≈ôev√©st zlomek v tvaru $\frac{x}{y}$ na tvar $\frac{1}{a}+\frac{1}{b}+\frac{1}{c}+\dots $ (Fibonacciho algoritmus)

##### Pom≈Øcka

Odkud vezmeme posloupnost pro testov√°n√≠ dom√°c√≠ho √∫kolu?

```python
from random import randint

low = 0
high = 10
n = 10

print([randint(low, high) for i in range(10)])
```

