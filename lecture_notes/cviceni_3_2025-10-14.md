

## `ProgramovÃ¡nÃ­` 1 pro matematiky

# 3. cviÄenÃ­, 14-10-2024



**Obsah**:

0. FarnÃ­ oznamy
1. OpakovÃ¡nÃ­
2. DomÃ¡cÃ­ Ãºkoly
3. Resty z minula
4. Seznamy



### FarnÃ­ oznamy

1. **MateriÃ¡ly k pÅ™ednÃ¡Å¡kÃ¡m** najdete v GitHub repozitÃ¡Å™i https://github.com/PKvasnick/Programovani-1. Najdete tam takÃ© kÃ³d ke cviÄenÃ­m.
2. **DomÃ¡cÃ­ Ãºkoly** MinulÃ½ tÃ½den jste dostali 2 pÅ™Ã­klady a nashromÃ¡Å¾dilo se docela hodnÄ› Å™esenÃ­. 
   * IndividuÃ¡lnÄ› se vyskytly problÃ©my s ReCodExem, zejmÃ©na  s pochopenÃ­m toho, Å¾e vÅ¡e, co napÃ­Å¡ete na vÃ½stup, povaÅ¾uje ReCodEx za souÄÃ¡st vaÅ¡eho Å™eÅ¡enÃ­. 
     * DÅ¯kladnÄ› ÄtÄ›te zadÃ¡nÃ­
     * NapiÅ¡te na vÃ½stup jenom odpovÄ›Ä v poÅ¾adovanÃ©m tvaru a nic vÃ­c. 
   * Vyskytla se ÄÃ¡st pÅ™Ã­liÅ¡ defenzivnÃ­ch Å™eÅ¡enÃ­. 
     * PoÅ™Ã¡dnÄ› si pÅ™eÄtÄ›te zadÃ¡nÃ­ a neÅ™eÅ¡te co se stane, kdyÅ¾ se na vstupu objevÃ­ nÄ›co jinÃ©ho neÅ¾ co uvÃ¡dÃ­ zadÃ¡nÃ­. 
     * A kdyÅ¾ uÅ¾ to Å™eÅ¡Ã­te, alespoÅˆ to Å™eÅ¡te sprÃ¡vnÄ›.
   * Vyskytlo se docela dost Ãºloh, pouÅ¾Ã­vajÃ­cÃ­ch pokroÄilejÅ¡Ã­ struktury Pythonu, napÅ™. funkce.  
     * v principu nenamÃ­tÃ¡m, ale myslete prosÃ­m na spoluÅ¾Ã¡ky, kteÅ™Ã­ stejnÃ½ Ãºkkol vyÅ™eÅ¡Ã­ za pomoci jednoduÅ¡Å¡Ã­ch prostÅ™edkÅ¯. Je vÃ¡Å¡ kÃ³d natolik elegantnÃ­, Å¾e to omlouvÃ¡ pouÅ¾Ã­vÃ¡nÃ­ tÄ›Å¾kÃ½ch zbranÃ­?

â€‹	K domÃ¡cÃ­m ÃºkolÃºm a ReCodExu se jeÅ¡tÄ› obÅ¡irnÄ›ji vrÃ¡tÃ­m.

3. **V nÃ¡sledujÃ­cÃ­ch dvou tÃ½dnech nÃ¡m odpadÃ¡ vÃ½uka.**. Abychom ztrÃ¡tu ÄÃ¡steÄnÄ› nahradili,  dostanete v kaÅ¾dÃ©m tÃ½dnu jeden domÃ¡cÃ­ Ãºkol a krÃ¡tkÃ© pouÄenÃ­ o nÄ›Äem novÃ©m v Pythonu, kterÃ© vÃ¡m s Ãºkolem pomÅ¯Å¾e.

------

## OpakovÃ¡nÃ­

... a co se poslednÄ› neveÅ¡lo:

**`if-elif-else`:**

```{python}
if podmÃ­nka1:
   pÅ™Ã­kazy1
elif podmÃ­nka2:
   pÅ™Ã­kazy2
else:		
   pÅ™Ã­kazy3
```
**PrÃ¡zdnÃ½ pÅ™Ã­kaz `pass`**

Tento pÅ™Ã­kaz pouÅ¾Ã­vÃ¡me tam, kde potÅ™ebujeme mÃ­t pÅ™Ã­kaz, ale vlastnÄ› nechceme nic udÄ›lat. ÄŒasto napÅ™Ã­klad v `if`, kdyÅ¾ se podmÃ­nka pÃ­Å¡e jednoduÅ¡eji neÅ¾ jejÃ­ negace:

```python
if podmÃ­nka:
    pass
else:
    pÅ™Ã­kazy
```

##### PÅ™Ã­kaz `match case`

```
match term:
    case pattern-1:
         action-1
    case pattern-2:
         action-2
    case pattern-3:
         action-3
    case _:
        action-default
```

Tento pÅ™Ã­kaz nÃ¡m umoÅ¾Åˆuje nahradit strukturu `if-elif-elif-...-else` v pÅ™Ã­padech, kdy vybÃ­rÃ¡me z vÄ›tÅ¡Ã­ho mnoÅ¾stvÃ­ voleb.

PodstatnÃ¡ vÃ½hoda `match case`  je, Å¾e umÃ­ pÅ™iÅ™azovat sloÅ¾itÄ›jÅ¡Ã­ vzory:

```python
point = (1, 2)

match point:
    case (0, 0):
        result = "Origin"
    case (x, 0):
        result = f"X-axis at {x}"
    case (0, y):
        result = f"Y-axis at {y}"
    case (x, y):
        result = f"Point at {x}, {y}"
```

V Pythonu existujÃ­ jeÅ¡tÄ› jinÃ© zpÅ¯soby implementace mnohonÃ¡sobnÃ©ho vÄ›tvenÃ­, napÅ™. pomocÃ­ slovnÃ­ku - to je velice typickÃ½ PythonskÃ½ postup:

```python
messages = {
    "JavaScript":"You can become a web developer.", 	"Python": "You can become a Data Scientist", 
    "PHP": "You can become a backend developer"
    ...
}
lang = input("What's the programming language you want to learn? ")
print(messages[lang])
```

---

**Cyklus `while`:**

```{python}
while podmÃ­nka:
   pÅ™Ã­kazy
```
PÅ™Ã­kazy pro kontrolu bÄ›hu cyklu:

`break` - v tomto mÃ­stÄ› opustit cyklus a pokraÄovat pÅ™Ã­kazem, nÃ¡sledujÃ­cÃ­m za cyklem

`continue` - v tomto mÃ­stÄ› pÅ™ejÃ­t na dalÅ¡Ã­ iteraci cyklu (tedy na testovÃ¡nÃ­ podmÃ­nky)

VÄ›tev `else`:

```{python}
while podmÃ­nka:
   pÅ™Ã­kazy
else
   pÅ™Ã­kazy-jen-jestli-probÄ›hl-celÃ½-cyklus
```

**PÅ™Ã­kaz print** 

```
print(a, b, c, ..., sep=<Å™etÄ›zec>, end=<Å™etÄ›zec>)
```

Default: `sep = " "`, `end = "\n"`

**f-Å™etÄ›zce**

```python
a = 5
b = 10.27
s = f"MÃ¡m {a} tyÄÃ­ s dÃ©lkou {b:.1f}m"
print(s)
---------
MÃ¡m 5 tyÄÃ­ s dÃ©lkou 10.3m
```

---

## DomÃ¡cÃ­ Ãºkoly

#### ProstÅ™edky Pythonu

HodnÄ› z vÃ¡s znÃ¡ z Pythonu vÃ­c, neÅ¾ jsme zatÃ­m probrali. PÅ™ijÃ­mÃ¡m i Å™eÅ¡enÃ­, kterÃ¡ pouÅ¾Ã­vajÃ­ prosÅ¥redky jazyka, kterÃ© jsme zatÃ­m neprobÃ­rali, 

- pokud to nenÃ­ v rozporu s ÃºÄelem zadÃ¡nÃ­ - tedy kdyÅ¾ mÃ¡te sami naprogramovat nÄ›co, na co existuje v Pythonu knihovnÃ­ funkce - napÅ™Ã­klad budeme programovat GCD(a,b), zatÃ­mco mÃ¡me funkci `math.gcd()`, kterÃ¡ to udÄ›lÃ¡ za vÃ¡s, nebo kdyÅ¾ mÃ¡te zjistit poÄet ÄÃ­slic celÃ©ho ÄÃ­sla bez pouÅ¾itÃ­ zkratky `len(str(n))`.
- pokud to vede k ÄistÅ¡Ã­mu a efektivnÃ­mu kÃ³du

CÃ­lem tohoto cviÄenÃ­ je nauÄit vÃ¡s psÃ¡t nejen sprÃ¡vnÃ½, ale i ÄistÃ½ a dobÅ™e ÄitelnÃ½ kÃ³d. Toho dosÃ¡hnete i ÃºÄelnÃ½m vyuÅ¾Ã­vÃ¡nÃ­m rozmanitÃ½ch prostÅ™edkÅ¯ jazyka.  

---

## Programujeme - pokraÄovÃ¡nÃ­ od minula

### Test prvoÄÃ­sel

Chceme otestovat, zda je ÄÃ­slo $n$ ze vstupu prvoÄÃ­slo.

Metoda: U vÅ¡ech ÄÃ­sel $d<n$ provÄ›Å™Ã­m, zda jsou dÄ›liteli $n$.

```{python}
# Otestuje, zda ÄÃ­slo je prvoÄÃ­slem

n = int(input())
d = 2
mam_delitele = False

while d < n:
    if n%d == 0:
        print("ÄŒÃ­slo", n, "je dÄ›litelnÃ©", d)
        mam_delitele = True
        break
    d += 1

if not mam_delitele:
    print("ÄŒÃ­slo", n, "je prvoÄÃ­slo")
```

To nenÃ­ nijak zvlÃ¡Å¡Å¥ efektivnÃ­ metoda, ale to nÃ¡m nevadÃ­, my jsme celÃ­ rÃ¡di, Å¾e umÃ­me napsat nÄ›co, co v zÃ¡sadÄ› funguje. 

PojÄme opatrnÄ› vylepÅ¡ovat. ZÃ¡sadnÃ­ vylepÅ¡enÃ­ kÃ³du by bylo, kdybychom "nahÃ½" cyklus `while` umÄ›li celÃ½ zapouzdÅ™it do jedinÃ©ho pÅ™Ã­kazu. 

ğŸ˜ _PokroÄilÃ© kolegy poprosÃ­m o tvar onoho jedinÃ©ho pÅ™Ã­kazu._

(Co udÄ›lÃ¡ toto?`all(n % d for d in range(2, n))`)

Asi prvnÃ­ vÄ›c, kterÃ¡ nÃ¡m vadÃ­, je stavovÃ¡ promÄ›nnÃ¡ `mam_delitele`. A tÃ© se v prvnÃ­m kroku zbavÃ­me za pouÅ¾itÃ­ vÄ›tve `else`:

```{python}
# Otestuje, zda ÄÃ­slo je prvoÄÃ­slem (2. pokus)

n = int(input())
d = 2

while d < n:
    if n%d == 0:
        print("ÄŒÃ­slo", n, "je dÄ›litelnÃ©", d)
        break
    d += 1
else:
    print("ÄŒÃ­slo", n, "je prvoÄÃ­slo")
```

Jak bychom mohli dÃ¡l vylepÅ¡it nÃ¡Å¡ test?

PopÅ™emÃ½Å¡lÃ­me, a zatÃ­m vymyslÃ­me, jak bychom vypsali vÅ¡echna provÄÃ­sla menÅ¡Ã­ nebo rovnÃ¡ $n$. NejjednoduÅ¡Å¡Ã­ metoda bude projÃ­t vÅ¡echna ÄÃ­sla od 2 do $n$, u kaÅ¾dÃ©ho rozhodnout, zda je prvoÄÃ­slem, a jestli ano, vypsat ho. 

```python
# VypÃ­Å¡e vÅ¡echna prvoÄÃ­sla od 1 do n

n = int(input())

x = 2
while x <= n:		# vnÄ›jÅ¡Ã­ cyklus: ÄÃ­sla od 2 do n
    d = 2
    while d < x-1: 	# x urÄitÄ› dÄ›lÃ­ x, nemusÃ­me testovat
        if x%d == 0:
            break
        d += 1
    else:
        print(x)
    x += 1

```

Optimalizace je v tomto pÅ™Ã­padÄ› jeÅ¡tÄ› vÃ­ce nasnadÄ›, jenomÅ¾e si zatÃ­m neumÃ­me pamatovat vÄ›ci - napÅ™Ã­klad vÅ¡echna prvoÄÃ­sla, kterÃ© jsme dosud nalezli.

ğŸ˜ _PokroÄilÃ© kolegy_ poprosÃ­m o optimalizovanÃ½ algoritmus, napÅ™. Erastothenovo sÃ­to. 

My ale zaÄneme s jinou vÄ›cÃ­, a to je _organizace kÃ³du_. PoÅ¾adavek zjistit, zda je nÄ›jakÃ© ÄÃ­slo prvoÄÃ­slem, je dobÅ™e izolovatelnÃ½: potÅ™ebujeme jenom ono ÄÃ­slo a uÅ¾ nepotÅ™ebujeme znÃ¡t nic jinÃ©ho. Proto mÅ¯Å¾eme kÃ³d, zjiÅ¡Å¥ujÃ­cÃ­, zda je ÄÃ­slo prvoÄÃ­slem, izolovat do _funkce_.

```python
def is_prime(n):
	d = 2
	while d < n:
    	if n%d == 0:
            return False
	    d += 1
    return True

n = int(input())
if is_prime(n):
    print(f"{n} je prvoÄÃ­slo")
else:
    print(f"{n} nenÃ­ prvoÄÃ­slo")
```

Funkce v Pythonu: 

```python
def jmÃ©no_funkce(parametr1, parametr2, ...):
	pÅ™Ã­kazy
```

NÃ¡vratovÃ¡ hodnota funkce: `return vÃ½raz`. 

PozdÄ›ji budeme o funkcÃ­ch mluvit podrobnÄ›ji, a Å¾e bude o Äem mluvit, prozatÃ­m nÃ¡m staÄÃ­ tato jednoduchÃ¡ koncepce. 

-----

#### SouÄet posloupnosti ÄÃ­sel

```python
# NaÄteme ze vstupu posloupnost ÄÃ­sel, ukonÄenou -1.
# VypÃ­Å¡eme jejich souÄet. 

s = 0
while True:
    n = int(input())
    if n == -1:
        break
    s += n
print(s)
```

ProÄ nemÅ¯Å¾eme na konci jenom stisknout Enter a nezadat nic?

ğŸ˜ _PokroÄilÃ© kolegy poprosÃ­m_

- o variantu se stiskem Enter (`sys.stdin`)
- a o vypsÃ¡nÃ­ aritmetickÃ©ho prÅ¯mÄ›ru a standardnÃ­ odchylky.

**MroÅ¾Ã­ operÃ¡tor**

```python
>>> a = (b := 10)**2
>>> a
100
>>> b
10
>>> 
```

PÅ™iÅ™azenÃ­, kterÃ© vracÃ­ hodnotu. *PouÅ¾Ã­vat umÄ›Å™enÄ›.* 

### EuklidÅ¯v algoritmus

ZÃ¡kladnÃ­ verze s odeÄÃ­tÃ¡nÃ­m: $x>y: \gcd(x,y) = \gcd(x-y,y)$

```python
# NejvÄ›tÅ¡Ã­ spoleÄnÃ½ dÄ›litel: EuklidÅ¯v algoritmus s odÄÃ­tÃ¡nÃ­m

x = int(input())
y = int(input())

while x != y:
    if x > y:
        x -= y
    else:
        y -= x

print(x)

```

LadÃ­cÃ­ vÃ½pis: Pokud chceme vidÄ›t, jak si vedou ÄÃ­sla x a y v cyklu while, pÅ™idÃ¡me za rÃ¡dek s `while` pÅ™Ã­kaz

```python
print(f"{x=} {y=}")
```

Pokud je jedno z ÄÃ­sel o hodnÄ› menÅ¡Ã­ neÅ¾ druhÃ©, moÅ¾nÃ¡ budeme opakovanÄ› odeÄÃ­tat, a to nÃ¡s spomaluje (nÃ¡roÄnost algoritmu je lineÃ¡rnÃ­ v n). Je proto lepÅ¡Ã­ v jednom kroku odeÄÃ­tat kolikrÃ¡t to jde: _odeÄÃ­tÃ¡nÃ­ nahradÃ­me operacÃ­ modulo_:

```python
#!/usr/bin/env python3
# NejvÄ›tÅ¡Ã­ spoleÄnÃ½ dÄ›litel: EuklidÅ¯v algoritmus s modulem

x = int(input())
y = int(input())

while x > 0 and y > 0:
    if x > y:
        x %= y
    else:
        y %= x

if x > 0:
    print(x)
else:
    print(y)
```

ProtoÅ¾e `x % y < y`, po kaÅ¾dÃ© operaci modulo vÃ­me, jakÃ¡ je vzÃ¡jemnÃ¡ velikost x a y. KÃ³d tedy mÅ¯Å¾eme vÃ½raznÄ› zdokonalit:

```python
# NejvÄ›tÅ¡Ã­ spoleÄnÃ½ dÄ›litel: EuklidÅ¯v algoritmus s pÃ¡r triky navÃ­c

x = int(input())
y = int(input())

while y > 0:
    x, y = y, x%y

print(x)
```

Tady si vÅ¡imneme pÅ™iÅ™azenÃ­ `x, y = y, x%y`. Je to dvojÃ­ pÅ™iÅ™azenÃ­, ale nelze jej rozdÄ›lit na dvÄ› pÅ™iÅ™azenÃ­ `x=y` a `y=x%y`, protoÅ¾e druhÃ© pÅ™iÅ™azenÃ­ se po prvnÃ­m zmÄ›nilo na `y=y%y` a tedy y bude pÅ™iÅ™azena 0.  

1. MÅ¯Å¾eme se ptÃ¡t, proÄ to funguje (protoÅ¾e z dvojice na pravÃ© stranÄ› se pÅ™ed pÅ™iÅ™azenÃ­m vytvoÅ™Ã­ nemÄ›nnÃ¡ - konstantnÃ­ dvojice - _tuple_ - a ten se pÅ™i pÅ™iÅ™azenÃ­ "rozbalÃ­" do x a y). 
2. Jak byste takovÃ©to pÅ™iÅ™azenÃ­ rozepsali na jednoduchÃ¡ pÅ™iÅ™azenÃ­, aby to fungovalo?

Toto je uÅ¾ celkem vÃ½konnÃ½ algoritmus, poÄetnÃ­ nÃ¡roÄnost je $\sim \log n$ TeÄ mÅ¯Å¾eme dÄ›lat vÃ­c vÄ›cÃ­, napÅ™Ã­klad spoÄÃ­st Eulerovu funkci pro prvnÃ­ch miliÃ³n ÄÃ­sel a podobnÄ›. 

-----

## Seznamy

```python
>>> cisla = [1, 2, 3, 4, 5]
>>> type(cisla)
list
>>> cisla[0] # V Pythonu ÄÃ­slujeme od 0
1
>>> cisla[4] # takÅ¾e poslednÃ­ prvek je poÄet prvkÅ¯ - 1
5
>>> len(cisla) # poÄet prvkÅ¯ je len
5
>>> cisla[-1] # IndexovÃ¡nÃ­ je velmi flexibilnÃ­
5
>>> cisla[1:3]
[2, 3]
>>> cisla[0:5]
[1, 2, 3, 4, 5]
>>> cisla[:3]
[1, 2, 3]
>>> cisla[3:]
[4, 5]
>>> cisla[::-1]
[5, 4, 3, 2, 1]
>>> cisla.append(6) # PÅ™idÃ¡nÃ­ novÃ©ho prvku do seznamu
>>> cisla
[1, 2, 3, 4, 5, 6]
>>> cisla.pop()
6
>>> cisla
[1, 2, 3, 4, 5]
```

Seznamy mÅ¯Å¾ou obsahovat rÅ¯znÃ© vÄ›ci:

```python
zaci = ["Honza", "Jakub", "Franta"]
matice = [[1,2,3],[2,3,1]] # NeuÅ¾iteÄnÃ¡ implementace matice
matice[0]
>>> [1,2,3]
matice[1][1] 
>>> 3
>>> [1,2] + [3,4] # aritmetika pro seznamy
[1, 2, 3, 4]
>>> [1,2]*3
[1, 2, 1, 2, 1, 2]
```

 ... ale takÃ© poloÅ¾ky rÅ¯znÃ©ho druhu:

```python
>>> lst = [1,"Peter",True]
>>> lst
[1, 'Peter', True]
>>> del lst[0]
>>> lst
['Peter', True]
>>> 
```

Pozor na kopÃ­rovÃ¡nÃ­ seznamÅ¯:

```python
>>> a = ['jeden', 'dva', 'tri']
>>> b = a
>>> a[0] = 'jedna'
>>> b
['jedna', 'dva', 'tri']
>>> c = [[1,2]]*3
>>> c
[[1, 2], [1, 2], [1, 2]]
>>> c[0][0] = 0
>>> c
[[0, 2], [0, 2], [0, 2]]
```

Seznam umÃ­me lehce setÅ™Ã­dit nebo obrÃ¡tit:

```python
>>> c = [2,4,1,3]
>>> sorted(c)
[1,2,3,4]
>>> reversed(c)		# nevznikne novÃ½ seznam
<list_reverseiterator at 0x25cdadbffa0>
>>> list(reversed(c))
[4, 3, 2, 1]
>>> c.reverse()		# vytvoÅ™Ã­ novÃ½ seznam
[4, 3, 2, 1]
```

O tÅ™Ã­dÄ›nÃ­ budeme mluvit na nÃ¡sledujÃ­cÃ­m cviÄenÃ­. 

#### Cyklus `for` 

```python
In [9]: cisla = [1,1,2,3,5,8]

In [10]: for cislo in cisla:
    ...:     print(cislo, end = "-")
    ...:
1-1-2-3-5-8-
```

ÄŒasto chceme, aby cyklus probÃ­hal pÅ™es jednoduchou ÄÃ­selnou Å™adu, napÅ™. $1,2,\dots,n$. Na generovÃ¡nÃ­ takovÃ½chto Å™ad slouÅ¾Ã­ funkce `range`:

```python
>>> for i in range(5):
	print(i, end = ' ')
	
0 1 2 3 4 
```

`range` respektuje ÄÃ­slovacÃ­ konvence Pythonu a podporuje jeÅ¡tÄ› dalÅ¡Ã­ argumenty: zaÄÃ¡tek sekvence a krok:

```python
>>> for i in range(2,10,3):
...     print(i)
...
2
5
8
```

Argumenty nemusÃ­ bÃ½t kladnÃ¡ ÄÃ­sla, takÅ¾e mÅ¯Å¾eme lehko iterovat pozpÃ¡tku:

```python
>>> for i in range(9,-1,-1):
---    print(i, end = ' ') 
---
9 8 7 6 5 4 3 2 1 0 >>> 
```

Tedy chceme-li iterovat pozpÃ¡tku pÅ™es `range(n)`, pouÅ¾ijeme `range(n-1,-1, -1)`.Abychom se nespletli, nabÃ­zÃ­ Python elegantnÄ›jÅ¡Ã­ Å™eÅ¡enÃ­:

```python
>>> for i in reversed(range(5)):
	print(i, end = " ")

4 3 2 1 0 
```

a tuto funkci mÅ¯Å¾eme pouÅ¾Ã­t na libovolnÃ½ seznam:

```python
>>> cisla = ["jedna", "dvÄ›", "tÅ™i", "ÄtyÅ™i"]
>>> for cislo in reversed(cisla):
	print(cislo, end = " ")

ÄtyÅ™i tÅ™i dvÄ› jedna 
```

`range(n)` nenÃ­ seznam, i kdyÅ¾ podporuje pÅ™Ã­stup k polÅ¾kÃ¡m pÅ™es index:

```python
>>> range(10)
range(0, 10)
>>> type(range(10))
<class 'range'>
>>> range(10)[-1]
9
>>> list(range(10))
[0,1,2,3,4,5,6,7,8,9]
>>> [i for i in range(10)]
[0,1,2,3,4,5,6,7,8,9]
```

TakÃ© `reversed/seznam)`nenÃ­ seznam, ale reverznÃ­ iterÃ¡tor:

```python
>>> reversed(cisla)
<list_reverseiterator object at 0x000002AE55D45370>
>>> [s for s in reversed(cisla)]
['ÄtyÅ™i', 'tÅ™i', 'dvÄ›', 'jedna']
```

ale `sorted(seznam)` je seznam:

```python
>>> sorted(c)
[1, 2, 3, 4]
```

#### Fibonacciho ÄÃ­sla

$$
Fib(0) = 1,\\
Fib(1) = 1,\\
Fib(n) = Fib(n-1) + Fib(n-2),\quad = 2, 3, \dots
$$



*Ãšloha*: VypiÅ¡te prvnÃ­ch n Fibonacciho ÄÃ­sel. 

Ãšvahy: 

- potÅ™ebujeme vÅ¯bec seznam?

```python
# Vypsat prvnich n Fibonacciho cisel
n = int(input())
a = 1
print(a, end = ", ")
b = 1
print(b, end = ", ")
for k in range(3,n+1):
    b, a = b+a, b
    print(b, end = ", ")
```

- MÅ¯Å¾eme zaÄÃ­t seznamem prvnÃ­ch dvou ÄÃ­sel, a pak dopoÄÃ­tÃ¡vat a pÅ™idÃ¡vat na konec dalÅ¡Ã­ ÄÃ­sla:

  ```python
  # Vypsat prvnich n Fibonacciho cisel
  n = int(input())
  fibs = [1,1]
  while len(fibs)<n:
  	fibs.append(fibs[-1] + fibs[-2])
  print(fibs)
  ```

- Nikdy nechcete alokovat pamÄ›Å¥ po malÃ½ch kouscÃ­ch. KdyÅ¾ pÅ™edem vÃ­me dÃ©lku seznamu, je nejlepÅ¡Ã­ zÅ™Ã­dit ho celÃ½ a jenom ho naplnit. 

#### PÅ™Ã­klad: ErastothÃ©novo sÃ­to

*Ãšloha*: NajdÄ›te vÅ¡echna prvoÄÃ­sla menÅ¡Ã­ nebo rovnÃ¡ n.

Ãšvahy:

- MusÃ­me si nÄ›jak pamatovat, kterÃ¡ ÄÃ­sla jsme uÅ¾ vyÅ¡ktrtli a kterÃ¡ nÃ¡m jeÅ¡tÄ› zÅ¯stala. 
- Jedno Å™eÅ¡enÃ­ je, Å¾e vezmeme seznam vÅ¡ech ÄÃ­sel od 2 do n a budeme odstraÅˆovat ty, kterÃ© nejsou prvoÄÃ­sly. To je ale pomalÃ© a v promÄ›nlivÃ©m poli se Å¡patnÄ› iteruje - nenÃ­ snadnÃ© urÄit, kde prÃ¡vÄ› v poli jsme. 
- LepÅ¡Ã­ je vzÃ­t seznam logickÃ½ch hodnot. Index bude ÄÃ­slo, a hodnota bude oznaÄovat, jestli jej zatÃ­m povaÅ¾ujeme za prvoÄÃ­slo anebo uÅ¾ ne. 

```python
# vypiÅ¡ vÅ¡echna prvoÄÃ­sla menÅ¡Ã­ nebo rovnÃ¡ n

n = int(input())

prvocisla = [True]*(n+1) # vÄetnÄ› nuly a n
prvocisla[0] = False
prvocisla[1] = False
for i in range(2,n+1):
    if prvocisla[i]:
        for j in range(i*i, n+1, i):
            prvocisla[j]=False

print("Pocet: ", sum(prvocisla))
for i in range(n+1):
    if prvocisla[i]:
        print(i, end = ', ')
```

-----

#### DalÅ¡Ã­ Ãºkoly

- NajdÄ›te ÄÃ­slo zapsanÃ© samÃ½mi jedniÄkami (v desÃ­tkovÃ© soustavÄ›), kterÃ© je dÄ›litelnÃ© zadanÃ½m K. Jak se vÄas zastavit, kdyÅ¾ neexistuje? 	
- NajdÄ›te ÄÃ­slo mezi 1 a N s co nejvÃ­ce dÄ›liteli.	

**DomÃ¡cÃ­ Ãºkoly na pÅ™Ã­Å¡tÃ­ tÃ½den:**

- Na vstupu kladnÃ© celÃ© n. Vypsat poÄet PytagorejskÃ½ch trojic s ÄÃ­sly menÅ¡Ã­mi neÅ¾ n. U tÃ©to Ãºlohy prohledÃ¡vÃ¡te prostor trojic pÅ™irozenÃ½ch ÄÃ­sel a je uÅ¾iteÄnÃ© zvolit promyÅ¡lenÄ› poÅ™adÃ­ filtrÅ¯.
- PÅ™evÃ©st zlomek v tvaru $\frac{x}{y}$ na tvar $\frac{1}{a}+\frac{1}{b}+\frac{1}{c}+\dots $ (FibonacciÅ¯v algoritmus)

U obou Ãºloh je rozumnÃ© posadit se na chvÃ­li s tuÅ¾kou a papÃ­rem, neÅ¾ zaÄnete psÃ¡t kÃ³d.

##### PomÅ¯cka 1

```python
>>> "1 2 3".split()
["1", "2", "3"]
>>> [int(s) for s in "1 2 3".split()]
[1, 2, 3]
>>> 
```

##### PomÅ¯cka 2

NÃ¡hodnÃ¡ ÄÃ­sla pro testovÃ¡nÃ­ domÃ¡cÃ­ho Ãºkolu:

```python
from random import randint

low = 0
high = 10
n = 10

print([randint(low, high) for i in range(10)])
```

