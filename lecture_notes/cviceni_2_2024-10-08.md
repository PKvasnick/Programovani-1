## Programov√°n√≠ 1 pro matematiky


# 2. cviƒçen√≠, 08-10-2023

**Obsah**:

0. Farn√≠ oznamy
1. Opakov√°n√≠: datov√© typy v Pythonu
2. P≈ô√≠kaz `if` 
3. P≈ô√≠kaz `while`
4. Programujeme...

------



### Farn√≠ oznamy

1. **Materi√°ly k p≈ôedn√°≈°k√°m** najdete v GitHub repozit√°≈ôi https://github.com/PKvasnick/Programovani-1. Najdete tam tak√© k√≥d ke cviƒçen√≠m.
   - Soubory si m≈Ø≈æete ƒç√≠st p≈ô√≠mo na GitHubu. Pokud si chcete st√°hnout nebo zkop√≠rovat k√≥d, p≈ôepnƒõte do _Raw_ zobrazen√≠ (aby se v√°m nezkop√≠rovaly ƒç√≠sla ≈ô√°dk≈Ø a pod.), Ctrl-A + Ctrl-C.
   - Windows: Nainstalujte si aplikaci GitHub Desktop a naklonujte si cel√Ω repozit√°≈ô do sv√©ho poƒç√≠taƒçe: Zelen√© tlaƒç√≠tko `Code`, z nab√≠dky `Open with GitHub Desktop`. 
   - Pokud se v nƒõjak√©m okam≈æiku neobejdete bez z≈ô√≠zen√≠ konta na GitHubu, z≈ôiƒète si jej. 

2. **Dom√°c√≠ √∫koly** A≈æ dnes dostanete prvn√≠ dom√°c√≠ √∫koly. 


3. **Ka≈æd√©mu v≈°e chod√≠?** - Python? ReCodEx?

-----

### Kv√≠z

Kter√© z n√°sleduj√≠c√≠ch ≈ôetƒõzc≈Ø jsou spr√°vn√Ωmi n√°zvy promƒõnn√© v Pythonu?

```python
a123
MamHlad
m√°m_hlad
d√©lka.chodidla
Œ≤
5tibe≈•an≈Ø
```

---

### Opakov√°n√≠ + nƒõco nov√© k tomu

#### Matematick√© funkce

```{python}
>>> import math
>>> math.pi
3.141592653589793
>>> math.sin(math.pi / 3)
0.8660254037844386
```

*math* je modul. Modul je nƒõco jako adres√°≈ô pln√Ω Pythonsk√©ho k√≥du, kter√Ω si p≈ôit√°hnete do sv√©ho programu, a z√≠sk√°te tak p≈ô√≠stup k funkc√≠m a t≈ô√≠d√°m modulu. 



#### N√°povƒõda

```{python}
>>> help(math.sin)
>>> help(math)
```



#### Logick√© v√Ωrazy

```{python}
>>> 5**7 > 7**5
True
>>> math.cos(0) < 0
False
>>> 0.8 <= sin(pi/3) <= 0.9
True
>>> pi>3 and pi<4
True
>>> x>0 or not x>0
True
>>> 1 == 1
True
>>> 1 != 2
True
```



#### Seznamy, mno≈æiny, slovn√≠ky

```python
>>> seznam = [1, 2, 3]
>>> seznam[0]
1
>>> seznam[1]
2
>>> seznam.append(4)
>>> seznam
[1, 2, 3, 4]
>>> seznam.pop()
4
>>> seznam
[1, 2, 3]
```

```python
>>> ovoce = {"jablka", "hru≈°ky", "pomeranƒçe"}
>>> ovoce.add("≈°vestky")
>>> ovoce
{"jablka", "hru≈°ky", "≈°vestky", "pomeranƒçe"}
>>> "hru≈°ky" in ovoce
True
>>> "ananas" in ovoce
False
>>> ovoce.add("hru≈°ky")
>>> ovoce
{"jablka", "hru≈°ky", "≈°vestky", "pomeranƒçe"}
```

```python
>>> ƒç√≠slice = {"jedna" : 1, "dva" : 2, "t≈ôi" : 3}
>>> ƒç√≠slice["t≈ôi"]
3
>>> ƒç√≠slice["ƒçty≈ôi"] = 4
>>> ƒç√≠slice
{"jedna" : 1, "dva" : 2, "t≈ôi" : 3, "ƒçty≈ôi" : 4}
```



####  Znakov√© ≈ôetƒõ≈æce

```python
s = 'Hello, world'
s
s[2]
s[2:5]
"wor" in s
```

M≈Ø≈æeme pou≈æ√≠vat jednoduch√© i dvojit√© uvozovky, i kdy≈æ jednoduch√© jsou pro Python typiƒçtƒõj≈°√≠. Indexov√°n√≠ zaƒç√≠n√° nulou. ≈òetƒõzce m≈Ø≈æeme tak√© seƒç√≠tat:

```python
s1='Hello'
s2 = 'world'
s1 + ' ' + s2
```

---

#### N√°≈° prvn√≠ program: poƒç√≠t√°me od 1 do 10

```{python}
i = 1
while i <= 10:
   print(i)
   i += 1
```

Odsazen√≠ funguje jako programovac√≠ z√°vorky a je v Pythonu nekompromisnƒõ vy≈æadov√°no. Mus√≠ b√Ωt konzistentn√≠, tedy stejn√© a nen√≠ povoleno st≈ô√≠dat mezery a tabul√°tory. Tedy poka≈æd√© pro stejnou √∫rove≈à stejn√© odsazen√≠. 

```{python}
i = 1
while i <= 10:
   if i%2 == 0:
      print(i)
   i += 1
```

Teƒè se je≈°tƒõ zept√°me, do kolika se m√° poƒç√≠tat:

```{python}
n = int(input("Do kolika chce≈° poƒç√≠tat? "))
i = 1
while i <= n:
   if i%2 == 0:
      print(i)
   i += 1
```

Nakonec m≈Ø≈æeme p≈ôidat do textu koment√°≈ôe: Python ignoruje znaky za `#` a≈æ do konce ≈ô√°dku.
Koment√°≈ô s vyk≈ôiƒçn√≠kem v prvn√≠m ≈ô√°dku, `#!/usr/bin/env python3`, se naz√Ωv√° _shebang_ a v unixov√Ωch syst√©mech informuje, jak se m√° soubor spustit. 

```{python}
#!/usr/bin/env python3

# Nejprve zjist√≠me, do kolika poƒç√≠tat
n = int(input("Do kolika chce≈° poƒç√≠tat? "))

# Aktu√°ln√≠ ƒç√≠slo
i = 1
while i <= n: 			# Je≈°tƒõ pokraƒçovat?
   if i%2 == 0: 		# Je ƒç√≠slo sud√©?
      print(i)
   i += 1 				# Dal≈°√≠, pros√≠m!
```

Rad≈°i nepou≈æ√≠vejte v zdrojov√©m k√≥du a v koment√°≈ô√≠ch diakritiku, pokud to nen√≠ nevyhnutn√©. M≈Ø≈æete obƒças narazit na nep≈ô√≠jemn√© probl√©my. 



### Vstup z konzole

`print` n√°m tiskne vƒõci z programu, `input` n√°m umo≈æ≈àuje naƒç√≠st z konzole vstup:

```python
a = input()
b = input()
print(a, b, a>b)

=============== RESTART: C:\Users\kvasn\Dropbox\Python_MFF\sk.py ===============
2
13
2 13 True
```

```python
a = int(input())
b = int(input())
print(a, b, a>b)

=============== RESTART: C:\Users\kvasn\Dropbox\Python_MFF\sk.py ===============
2
13
2 13 False
```

**input() a ReCodEx**

1. Funkce `input()` funguje v ReCodExu pon√©kud jinak ne≈æ na va≈°i konzole. ReCodEx p≈ôi hodnocen√≠ va≈°ich √∫loh p≈ôesmƒõruje soubor se vstupn√≠mi √∫daji pro bƒõh programu na standardn√≠ vstup programu. Zat√≠mco p≈ôi pou≈æit√≠ `input()` na konzoli je v√Ωstupem znakov√Ω ≈ôetƒõzec, kter√Ω jste zadali, bez koncov√©ho znaku nov√©ho ≈ô√°dku (\n), v ReCodExu bude vstup obsahovat i koncov√© \n. 
2. Pro √∫lohy odevzd√°van√© v ReCodExu **nikdy** nepou≈æ√≠vejte v√Ωzvu ve funkci `input()`. Tedy v≈ædy volejte funkci bez parametr≈Ø, `input()` a ne `input("Zadej cislo: ")` nebo nƒõco podobn√©ho.



#### Introspekce

Objekty v Pythonu vƒõd√≠, jak√©ho jsou typu, a r≈Øzn√© typy m≈Ø≈æeme konvertovat na jin√©:

```python
a = 3.1
b = 4.5
a+b
type(a)
type(b)
c = int(a)
c
type(c)
```

Nejsp√≠≈° v√°s nep≈ôekvap√≠, ≈æe tak√© existuje `float()`, `str()` a `bool()`


```{python}
In [3]: int(4.9)
Out[3]: 4

In[4]: int("Petr")
Traceback (most recent call last):
  File "<pyshell#72>", line 1, in <module>
    int("Petr")
ValueError: invalid literal for int() with base 10: 'Petr'

In [5]: round(4.9,0)
Out[5]: 5.0

In [6]: float(5)
Out[6]: 5.0

In [7]: bool(0.5)
Out[7]: True

In [8]: bool(-1.0)
Out[8]: True

In [9]: bool(0.0)
Out[9]: False

In [10]: str(4.6)
Out[10]: '4.6'

In [11]: str(True)
Out[11]: 'True'

In [12]: str(False)
Out[12]: 'False'


```

- [ ] Oper√°tory `+,-,*,/,**,//,%, ==, and, or, not`

- [ ] P≈ôi≈ôazen√≠ `=` a p≈ôi≈ôazen√≠ s operac√≠ `¬∞+=, -=, *=, /=`, ale tak√© t≈ôeba `%=` - oper√°tor _vymodulen√≠_, s kter√Ωm se dnes setk√°me.

- [ ] Matematick√© funkce z bal√≠ku _math_,  `import math` a pak `math.*`, nap≈ô. `math.sin()`.

- [ ] Funkce pro ƒçten√≠ ≈ôetƒõzce ze standardn√≠ho vstupu `input(v√Ωzva)` a funkce pro tisk do standardn√≠ho v√Ωstupu `print(objekt1, objekt2, ...)`


### Print podrobnƒõji

```python
print(1,2,3); print(4,5,6)
1 2 3
4 5 6
```

Konverze do ≈ôetƒõzcov√© reprezentace, polo≈æky oddƒõlen√© mezerami, na konci znak nov√©ho ≈ô√°dku.

```python
print(1, 2, 3, sep = "-", end = "!!!\n")
```

Form√°tov√°n√≠ v√Ωstupu:

```python
jmeno = "Petr"
vaha = 100
print(jmeno, "v√°≈æ√≠", vaha, "kilogram≈Ø")
print(f"{jmeno} v√°≈æ√≠ {vaha} kilogram≈Ø")
```



### P≈ô√≠kazy `if` a `while`

- [ ] Podm√≠nƒõn√Ω p≈ô√≠kaz 

  ```{python}
  if podm√≠nka:
     p≈ô√≠kazy
  ```

- [ ] P≈ô√≠kaz cyklu

  ```{python}
  while podm√≠nka:
     p≈ô√≠kazy
  ```

  kde _p≈ô√≠kazy_ m≈Ø≈æou b√Ωt p≈ô√≠kazy p≈ôi≈ôazen√≠, vol√°n√≠ funkce, dal≈°√≠ podm√≠nƒõn√© p≈ô√≠kazy nebo p≈ô√≠kazy cyklu, a dnes se nauƒç√≠me, ≈æe tak√© p≈ô√≠kazy `pass` (nedƒõlej nic), `break` (opu≈°tƒõn√≠ cyklu) a `continue` (p≈ôechod na dal≈°√≠ iteraci cyklu).

-----

#### P≈ô√≠kaz `if`

√öplnƒõj≈°√≠ syntaxe p≈ô√≠kazu `if`:

```{python}
if podm√≠nka:
   p≈ô√≠kazy
else:			# volitelnƒõ
   p≈ô√≠kazy
```

Vƒõtev `else` je nepovinn√°; kdy≈æ chceme vynechat p≈ô√≠kazy ve vƒõtvi `if`, mus√≠me pou≈æ√≠t pr√°zdn√Ω p≈ô√≠kaz `pass`. 

Vƒõtve `elif`: V p≈ô√≠padƒõ ≈ôetƒõz√≠c√≠ch p≈ô√≠kaz≈Ø `if` m≈Ø≈æeme nam√≠sto konstrukce

```{python}
if podm√≠nka1:
   p≈ô√≠kazy
else:
   if podm√≠nka2:
      p≈ô√≠kazy
   else:
      p≈ô√≠kazy
         
```

ps√°t

```{python}
if podm√≠nka1:
   p≈ô√≠kazy
elif podm√≠nka2:
   p≈ô√≠kazy
else:
   p≈ô√≠kazy
```

co≈æ je o nƒõco p≈ôehlednƒõj≈°√≠ - hlavnƒõ d√≠ky ploch√©mu (nerostouc√≠mu) odsazen√≠.

---

##### P≈ô√≠kaz `match case`

```
match term:
    case pattern-1:
         action-1
    case pattern-2:
         action-2
    case pattern-3:
         action-3
    case _:
        action-default
```

Tento p≈ô√≠kaz n√°m umo≈æ≈àuje nahradit strukturu `if-elif-else` v p≈ô√≠padech, kdy vyb√≠r√°me z vƒõt≈°√≠ho mno≈æstv√≠ voleb:

Nam√≠sto 

```python
lang = input("What's the programming language you want to learn? ")

if lang == "JavaScript":
    print("You can become a web developer.")
elif lang == "PHP":
    print("You can become a backend developer.")
elif lang == "Python":
    print("You can become a Data Scientist")
elif lang == "Solidity":
    print("You can become a Blockchain developer.")
elif lang == "Java":
    print("You can become a mobile app developer")
else:
    print("The language doesn't matter, what matters is solving problems.")

print(switch("JavaScript"))   
print(switch("PHP"))   
print(switch("Java"))  

"""
Output: 
You can become a web developer.
You can become a backend developer.
You can become a mobile app developer
"""

```

m≈Ø≈æeme ps√°t

```python
lang = input("What's the programming language you want to learn? ")

match lang:
    case "JavaScript":
        print("You can become a web developer.")

    case "Python":
        print("You can become a Data Scientist")

    case "PHP":
        print("You can become a backend developer")

    case "Solidity":
        print("You can become a Blockchain developer")

    case "Java":
        print("You can become a mobile app developer")
    case _:
        print("The language doesn't matter, what matters is solving problems.")
```

V Pythonu existuj√≠ je≈°tƒõ jin√© zp≈Øsoby implementace mnohon√°sobn√©ho vƒõtven√≠, nap≈ô. pomoc√≠ slovn√≠ku. 

`match case` ale um√≠ p≈ôi≈ôazovat slo≈æitƒõj≈°√≠ vzory:

```python
point = (1, 2)

match point:
    case (0, 0):
        result = "Origin"
    case (x, 0):
        result = f"X-axis at {x}"
    case (0, y):
        result = f"Y-axis at {y}"
    case (x, y):
        result = f"Point at {x}, {y}"
```



-----

#### P≈ô√≠kaz `while`

```{python}
while podm√≠nka:
   p≈ô√≠kazy
```

P≈ô√≠kazy pro kontrolu bƒõhu cyklu:

`break` - v tomto m√≠stƒõ opustit cyklus a pokraƒçovat p≈ô√≠kazem, n√°sleduj√≠c√≠m za cyklem

`continue` - v tomto m√≠stƒõ p≈ôej√≠t na dal≈°√≠ iteraci cyklu (tedy na testov√°n√≠ podm√≠nky)

Nekoneƒçn√Ω cyklus: podm√≠nka st√°le plat√≠, a o ukonƒçen√≠ cyklu rozhodneme v tƒõle za pou≈æit√≠ p≈ô√≠kazu `break`:

```{python}
while True:
   p≈ô√≠kazy
   if podm√≠nka:
      break
```

P≈ô√≠kaz `while` m√° tak√© volitelnou v√©tev `else`. P≈ô√≠kazy v t√©to vƒõtvi se vykonaj√≠, pokud cyklus ≈ô√°dnƒõ skonƒç√≠ (tedy ne v p≈ô√≠padƒõ opu≈°tƒõn√≠ cyklu p≈ô√≠kazem `break`).

```{python}
while podm√≠nka:
   p≈ô√≠kazy1
else:
   p≈ô√≠kazy2
```

-----

### P≈ô√≠klady

#### Test prvoƒç√≠sel

Chceme otestovat, zda je ƒç√≠slo $n$ ze vstupu prvoƒç√≠slo.

Metoda: U v≈°ech ƒç√≠sel $d<n$ provƒõ≈ô√≠m, zda jsou dƒõliteli $n$.

```{python}
#!/usr/bin/env python3

# Otestuje, zda ƒç√≠slo je prvoƒç√≠slem

n = int(input())
d = 2
mam_delitele = False

while d < n:
    if n%d == 0:
        print("ƒå√≠slo", n, "je dƒõliteln√©", d)
        mam_delitele = True
        break
    d += 1

if not mam_delitele:
    print("ƒå√≠slo", n, "je prvoƒç√≠slo")
```

To nen√≠ nijak zvl√°≈°≈• efektivn√≠ metoda, ale to n√°m nevad√≠, my jsme cel√≠ r√°di, ≈æe um√≠me napsat nƒõco, co v z√°sadƒõ funguje. 

Pojƒème opatrnƒõ vylep≈°ovat. Z√°sadn√≠ vylep≈°en√≠ k√≥du by bylo, kdybychom "nah√Ω" cyklus `while` umƒõli cel√Ω zapouzd≈ôit do jedin√©ho p≈ô√≠kazu. 

üòé _Pokroƒçil√© kolegy popros√≠m o tvar onoho jedin√©ho p≈ô√≠kazu._

Asi prvn√≠ vƒõc, kter√° n√°m vad√≠, je stavov√° promƒõnn√° `mam_delitele`. A t√© se v prvn√≠m kroku zbav√≠me za pou≈æit√≠ vƒõtve `else`:

```{python}
#!/usr/bin/env python3

# Otestuje, zda ƒç√≠slo je prvoƒç√≠slem (2. pokus)

n = int(input())
d = 2

while d < n:
    if n%d == 0:
        print("ƒå√≠slo", n, "je dƒõliteln√©", d)
        break
    d += 1
else:
    print("ƒå√≠slo", n, "je prvoƒç√≠slo")
```

Jak bychom mohli d√°l vylep≈°it n√°≈° test?

Pop≈ôem√Ω≈°l√≠me, a zat√≠m vymysl√≠me, jak bychom vypsali v≈°echna provƒç√≠sla men≈°√≠ nebo rovn√° $n$. Nejjednodu≈°≈°√≠ metoda bude proj√≠t v≈°echna ƒç√≠sla od 2 do $n$, u ka≈æd√©ho rozhodnout, zda je prvoƒç√≠slem, a jestli ano, vypsat ho. 

```python
#!/usr/bin/env python3
# Vyp√≠≈°e v≈°echna prvoƒç√≠sla od 1 do n

n = int(input())

x = 2
while x <= n:
    d = 2
    while d < x:
        if x%d == 0:
            break
        d += 1
    else:
        print(x)

    x += 1

```

Optimalizace je v tomto p≈ô√≠padƒõ je≈°tƒõ v√≠ce nasnadƒõ, jenom≈æe si zat√≠m neum√≠me pamatovat vƒõci - nap≈ô√≠klad v≈°echna prvoƒç√≠sla, kter√© jsme dosud nalezli.

üòé _Pokroƒçil√© kolegy_ popros√≠m o optimalizovan√Ω algoritmus, nap≈ô. Erastothenovo s√≠to. 

-----

#### Souƒçet posloupnosti ƒç√≠sel

```python
#!/usr/bin/env python3

# Naƒçteme ze vstupu posloupnost ƒç√≠sel, ukonƒçenou -1.
# Vyp√≠≈°eme jejich souƒçet. 

s = 0
while True:
    n = int(input())
    if n == -1:
        break
    s += n
print(s)
```

Proƒç nem≈Ø≈æeme na konci jenom stisknout Enter a nezadat nic?

üòé _Pokroƒçil√© kolegy popros√≠m_

- o variantu se stiskem Enter 
- a pro vyps√°n√≠ aritmetick√©ho pr≈Ømƒõru a standardn√≠ odchylky._

---

**Dom√°c√≠ √∫kol na p≈ô√≠≈°t√≠ t√Ωden:**

* Obr a princezna (velice snadn√Ω √∫kol pro otestov√°n√≠ pr√°ce s ReCodExem)
* Spoƒç√≠st a vypsat poƒçet cifer zadan√©ho cel√©ho ƒç√≠sla
* Vypsat zadan√© cel√© ƒç√≠slo jako souƒçin prvoƒçinitel≈Ø 

10 bod≈Ø / √∫kol do pondƒõl√≠, pak 5 do dal≈°√≠ nedƒõle. P≈ô√≠≈°t√≠ √∫ter√Ω d√°m n√°vody k vƒõcem, kde uvid√≠m probl√©my, ≈ôe≈°en√≠ zve≈ôejn√≠m v nedƒõli. 
