

## `ProgramovÃ¡nÃ­` 1 pro matematiky

# 3. cviÄenÃ­, 18-10-2021



**Obsah**:

0. FarnÃ­ oznamy
1. OpakovÃ¡nÃ­
2. DomÃ¡cÃ­ Ãºkoly
3. Resty z minula
4. Seznamy



### FarnÃ­ oznamy

1. **MateriÃ¡ly k pÅ™ednÃ¡Å¡kÃ¡m** najdete v GitHub repozitÃ¡Å™i https://github.com/PKvasnick/Programovani-1. Najdete tam takÃ© kÃ³d ke cviÄenÃ­m.
2. **DomÃ¡cÃ­ Ãºkoly** MinulÃ½ tÃ½den jste dostali 3 pÅ™Ã­klady a nashromÃ¡Å¾dilo se docela hodnÄ› Å™esenÃ­. 
   * MnozÃ­ mÄ›li problÃ©my s ReCodExem, zejmÃ©na  s pochopenÃ­m toho, Å¾e vÅ¡e, co napÃ­Å¡ete na vÃ½stup, povaÅ¾uje ReCodEx za souÄÃ¡st vaÅ¡eho Å™eÅ¡enÃ­. 
     * DÅ¯kladnÄ› ÄtÄ›te zadÃ¡nÃ­
     * NapiÅ¡te na vÃ½stup jenom odpovÄ›Ä v poÅ¾adovanÃ©m tvaru a nic vÃ­c. 
     * O tomto jsme mluvili na minulÃ©m cviÄenÃ­. Pokud se ho nÄ›kdo nezÃºÄastnil, trpÄ›livÄ› jsem vysvÄ›tlil, kde je problÃ©m, ale nemÅ¯Å¾ete oÄekÃ¡vat Ãºlevy za to, Å¾e jste nebyli na cviÄenÃ­.
   * Vyskytlo se docela dost Ãºloh, pouÅ¾Ã­vajÃ­cÃ­ch pokroÄilejÅ¡Ã­ struktury Pythonu, napÅ™. seznamy.  
     * v principu nenamÃ­tÃ¡m, ale myslete prosÃ­m na spoluÅ¾Ã¡ky, kteÅ™Ã­ stejnÃ½ Ãºkkol vyÅ™eÅ¡Ã­ za pomoci jednoduÅ¡Å¡Ã­ch prostÅ™edkÅ¯. Je vÃ¡Å¡ kÃ³d natolik elegantnÃ­, Å¾e to omlouvÃ¡ pouÅ¾Ã­vÃ¡nÃ­ nedovolenÃ½ch zbranÃ­?

K domÃ¡cÃ­m ÃºkolÃºm a ReCodExu se jeÅ¡tÄ› obÅ¡irnÄ›ji vrÃ¡tÃ­m.

------

## OpakovÃ¡nÃ­

**`if-elif-else`:**

```{python}
if podmÃ­nka1:
   pÅ™Ã­kazy1
elif podmÃ­nka2:
   pÅ™Ã­kazy2
else:		
   pÅ™Ã­kazy3
```
- [ ] **PrÃ¡zdnÃ½ pÅ™Ã­kaz `pass`**

**Cyklus `while`:**

```{python}
while podmÃ­nka:
   pÅ™Ã­kazy
```
PÅ™Ã­kazy pro kontrolu bÄ›hu cyklu:

`break` - v tomto mÃ­stÄ› opustit cyklus a pokraÄovat pÅ™Ã­kazem, nÃ¡sledujÃ­cÃ­m za cyklem

`continue` - v tomto mÃ­stÄ› pÅ™ejÃ­t na dalÅ¡Ã­ iteraci cyklu (tedy na testovÃ¡nÃ­ podmÃ­nky)

VÄ›tev `else`:

```{python}
while podmÃ­nka:
   pÅ™Ã­kazy
else
   pÅ™Ã­kazy-jen-jestli-probÄ›hl-celÃ½-cyklus
```

**PÅ™Ã­kaz print** 

```
print(a, b, c, ..., sep=<Å™etÄ›zec>, end=<Å™etÄ›zec>)
```

Default: `sep = " "`, `end = "\n"`

**f-Å™etÄ›zce**

```python
a = 5
b = 10.27
s = f"MÃ¡m {a} tyÄÃ­ s dÃ©lkou {b:.1f}m"
print(s)
---------
MÃ¡m 5 tyÄÃ­ s dÃ©lkou 10.3m
```

---

## DomÃ¡cÃ­ Ãºkoly

#### ÄŒistota a Äitelnost kÃ³du

Porovnejte prosÃ­m tyto dva kÃ³dy. Oba jsou sprÃ¡vnÃ© a dÄ›lajÃ­ sprÃ¡vnÄ› to, co majÃ­.  

Tento kÃ³d, vÄetnÄ› nÃ¡zvÅ¯ identifikÃ¡torÅ¯, vyvinulo nÄ›kolik z vÃ¡s:

```python
n=int(input())
m=int(input())
if n>m:
    print("P")
elif n<m:
    print("O")
else:
    print("R")
```

Porovnejte ho prosÃ­m s tÃ­mto kÃ³dem (to je takÃ© Å™eÅ¡enÃ­, pochÃ¡zejÃ­cÃ­ od jednoho z vÃ¡s):

```python
cislo_princezny = int(input())
cislo_obra = int(input())

if cislo_princezny > cislo_obra:
    print("P")
elif cislo_princezny < cislo_obra:
    print("O")
else:
    print("R")
```

ProblÃ©m s prvnÃ­m kÃ³dem je, Å¾e si nÄ›kde musÃ­te zapamatovat pÅ™iÅ™azenÃ­ nâ†’ÄÃ­slo od princezny, mâ†’ÄÃ­slo od obra. Pak prvnÃ­mu kÃ³du rozumÃ­te stejnÄ› dobÅ™e jako druhÃ©mu, ale v hlavÄ› musÃ­te drÅ¾et nÃ¡hodnou informaci, potÅ™ebnou k pochopenÃ­ kÃ³du. 

KÃ³d, kterÃ½ mÃ¡ krÃ¡tkÃ© nÃ¡zvy promÄ›nnÃ½ch, nenÃ­ v nijakÃ©m smyslu vÃ½konnÄ›jÅ¡Ã­ nebo ÃºspornÄ›jÅ¡Ã­ neÅ¾ kÃ³d s dlouhÃ½mi promÄ›nnÃ½mi. Na druhou stranu, kÃ³d s pÅ™Ã­liÅ¡ dlouhÃ½mi identifikÃ¡tory je prostÄ› vÃ­ce textu a mÅ¯Å¾e se hÅ¯Å™ ÄÃ­st. 

**JmÃ©na objektÅ¯ v Pythonu:** PoÄÃ¡teÄnÃ­ pÃ­smeno, pak kombinace velkÃ½ch i malÃ½ch pÃ­smen, ÄÃ­slic a podtrÅ¾Ã­tek. 

**SnaÅ¾te se prosÃ­m pouÅ¾Ã­vat nÃ¡zvy promÄ›nnÃ½ch, kterÃ© reflektujÃ­ jejich vÃ½znam. **

JeÅ¡tÄ› jeden problÃ©m s prvnÃ­m kÃ³dem:

Python pÅ™edpisuje kolem binÃ¡rnÃ­ch operÃ¡torÅ¯ **mezery**. VÃ½jimkou je pÅ™iÅ™azenÃ­ pojmenovanÃ½ch parametrÅ¯.  Mezi jmÃ©nem funkce a seznamem jejÃ­ch parametrÅ¯ v zÃ¡vorkÃ¡ch mezera *nenÃ­*. Mezery takÃ© patÅ™Ã­ za ÄÃ¡rky, oddÄ›lujÃ­cÃ­ prvky seznamu nebo n-tice.

Tedy

```python
a = b**2 + c**2
print("Petr", "Franta", "Josef", sep="-", end="konec\n")
n = int("3")
```

#### ProstÅ™edky Pythonu

HodnÄ› z vÃ¡s znÃ¡ z Pythonu vÃ­c, neÅ¾ jsme zatÃ­m probrali. PÅ™ijÃ­mÃ¡m i Å™eÅ¡enÃ­, kterÃ¡ pouÅ¾Ã­vajÃ­ prosÅ¥redky jazyka, kterÃ© jsme zatÃ­m neprobÃ­rali, 

- pokud to nenÃ­ v rozporu s ÃºÄelem zadÃ¡nÃ­ - tedy kdyÅ¾ mÃ¡te sami naprogramovat nÄ›co, na co existuje v Pythonu knihovnÃ­ funkce - napÅ™Ã­klad budeme programovat GCD(a,b), zatÃ­mco mÃ¡me funkci `math.gcd()`, kterÃ¡ to udÄ›lÃ¡ za vÃ¡s, nebo kdyÅ¾ mÃ¡te zjistit poÄet ÄÃ­slic celÃ©ho ÄÃ­sla bez pouÅ¾itÃ­ zkratky `len(str(n))`.
- pokud to vede k ÄistÅ¡Ã­mu a efektivnÃ­mu kÃ³du

CÃ­lem tohoto cviÄenÃ­ je nauÄit vÃ¡s psÃ¡t nejen sprÃ¡vnÃ½, ale i ÄistÃ½ a dobÅ™e ÄitelnÃ½ kÃ³d. Toho dosÃ¡hnete i ÃºÄelnÃ½m vyuÅ¾Ã­vÃ¡nÃ­m rozmanitÃ½ch prostÅ™edkÅ¯ jazyka.  

---

## Programujeme - pokraÄovÃ¡nÃ­ od minula

### Test prvoÄÃ­sel

Chceme otestovat, zda je ÄÃ­slo $n$ ze vstupu prvoÄÃ­slo.

Metoda: U vÅ¡ech ÄÃ­sel $d<n$ provÄ›Å™Ã­m, zda jsou dÄ›liteli $n$.

```{python}
#!/usr/bin/env python3

# Otestuje, zda ÄÃ­slo je prvoÄÃ­slem

n = int(input())
d = 2
mam_delitele = False

while d < n:
    if n%d == 0:
        print("ÄŒÃ­slo", n, "je dÄ›litelnÃ©", d)
        mam_delitele = True
        break
    d += 1

if not mam_delitele:
    print("ÄŒÃ­slo", n, "je prvoÄÃ­slo")
```

To nenÃ­ nijak zvlÃ¡Å¡Å¥ efektivnÃ­ metoda, ale to nÃ¡m nevadÃ­, my jsme celÃ­ rÃ¡di, Å¾e umÃ­me napsat nÄ›co, co v zÃ¡sadÄ› funguje. 

PojÄme opatrnÄ› vylepÅ¡ovat. ZÃ¡sadnÃ­ vylepÅ¡enÃ­ kÃ³du by bylo, kdybychom "nahÃ½" cyklus `while` umÄ›li celÃ½ zapouzdÅ™it do jedinÃ©ho pÅ™Ã­kazu. 

ğŸ˜ _PokroÄilÃ© kolegy poprosÃ­m o tvar onoho jedinÃ©ho pÅ™Ã­kazu._

Asi prvnÃ­ vÄ›c, kterÃ¡ nÃ¡m vadÃ­, je stavovÃ¡ promÄ›nnÃ¡ `mam_delitele`. A tÃ© se v prvnÃ­m kroku zbavÃ­me za pouÅ¾itÃ­ vÄ›tve `else`:

```{python}
#!/usr/bin/env python3

# Otestuje, zda ÄÃ­slo je prvoÄÃ­slem (2. pokus)

n = int(input())
d = 2

while d < n:
    if n%d == 0:
        print("ÄŒÃ­slo", n, "je dÄ›litelnÃ©", d)
        break
    d += 1
else:
    print("ÄŒÃ­slo", n, "je prvoÄÃ­slo")
```

Jak bychom mohli dÃ¡l vylepÅ¡it nÃ¡Å¡ test?

PopÅ™emÃ½Å¡lÃ­me, a zatÃ­m vymyslÃ­me, jak bychom vypsali vÅ¡echna provÄÃ­sla menÅ¡Ã­ nebo rovnÃ¡ $n$. NejjednoduÅ¡Å¡Ã­ metoda bude projÃ­t vÅ¡echna ÄÃ­sla od 2 do $n$, u kaÅ¾dÃ©ho rozhodnout, zda je prvoÄÃ­slem, a jestli ano, vypsat ho. 

```python
#!/usr/bin/env python3
# VypÃ­Å¡e vÅ¡echna prvoÄÃ­sla od 1 do n

n = int(input())

x = 2
while x <= n:
    d = 2
    while d < x:
        if x%d == 0:
            break
        d += 1
    else:
        print(x)

    x += 1

```

Optimalizace je v tomto pÅ™Ã­padÄ› jeÅ¡tÄ› vÃ­ce nasnadÄ›, jenomÅ¾e si zatÃ­m neumÃ­me pamatovat vÄ›ci - napÅ™Ã­klad vÅ¡echny prvoÄÃ­sla, kterÃ© jsme dosud nalezli.

ğŸ˜ _PokroÄilÃ© kolegy_ poprosÃ­m o optimalizovanÃ½ algoritmus, napÅ™. Erastothenovo sÃ­to. 

-----

#### SouÄet posloupnosti ÄÃ­sel

```python
#!/usr/bin/env python3

# NaÄteme ze vstupu posloupnost ÄÃ­sel, ukonÄenou -1.
# VypÃ­Å¡eme jejich souÄet. 

s = 0
while True:
    n = int(input())
    if n == -1:
        break
    s += n
print(s)
```

ProÄ nemÅ¯Å¾eme na konci jenom stisknout Enter a nezadat nic?

ğŸ˜ _PokroÄilÃ© kolegy poprosÃ­m_

- o variantu se stiskem Enter 
- a o vypsÃ¡nÃ­ aritmetickÃ©ho prÅ¯mÄ›ru a standardnÃ­ odchylky._

**MroÅ¾Ã­ operÃ¡tor**

```python
>>> a = (b := 10)**2
>>> a
100
>>> b
10
>>> 
```

PÅ™iÅ™azenÃ­, kterÃ© vracÃ­ hodnotu. *PouÅ¾Ã­vat umÄ›Å™enÄ›.* 

### EuklidÅ¯v algoritmus

ZÃ¡kladnÃ­ verze s odeÄÃ­tÃ¡nÃ­m: $x>y: \gcd(x,y) = \gcd(x-y,y)$

```python
#!/usr/bin/env python3
# NejvÄ›tÅ¡Ã­ spoleÄnÃ½ dÄ›litel: EuklidÅ¯v algoritmus s odÄÃ­tÃ¡nÃ­m

x = int(input())
y = int(input())

while x != y:
    if x > y:
        x -= y
    else:
        y -= x

print(x)

```

LadÃ­cÃ­ vÃ½pis: Pokud chceme vidÄ›t, jak si vedou ÄÃ­sla x a y v cyklu while, pÅ™idÃ¡me za rÃ¡dek s `while` pÅ™Ã­kaz

```python
print(f"{x=} {y=}")
```

Pokud je jedno z ÄÃ­sel o hodnÄ› menÅ¡Ã­ neÅ¾ druhÃ©, moÅ¾nÃ¡ budeme opakovanÄ› odeÄÃ­tat, a to nÃ¡s spomaluje (nÃ¡roÄnost algoritmu je lineÃ¡rnÃ­ v n). Je proto lepÅ¡Ã­ v jednom kroku odeÄÃ­tat kolikrÃ¡t to jde: _odeÄÃ­tÃ¡nÃ­ nahradÃ­me operacÃ­ modulo_:

```python
#!/usr/bin/env python3
# NejvÄ›tÅ¡Ã­ spoleÄnÃ½ dÄ›litel: EuklidÅ¯v algoritmus s modulem

x = int(input())
y = int(input())

while x > 0 and y > 0:
    if x > y:
        x %= y
    else:
        y %= x

if x > 0:
    print(x)
else:
    print(y)
```

ProtoÅ¾e `x % y < y`, po kaÅ¾dÃ© operaci modulo vÃ­me, jakÃ¡ je vzÃ¡jemnÃ¡ velikost x a y. KÃ³d tedy mÅ¯Å¾eme vÃ½raznÄ› zdokonalit:

```python
#!/usr/bin/env python3
# NejvÄ›tÅ¡Ã­ spoleÄnÃ½ dÄ›litel: EuklidÅ¯v algoritmus s pÃ¡r triky navÃ­c

x = int(input())
y = int(input())

while y > 0:
    x, y = y, x%y

print(x)
```

Tady si vÅ¡imneme pÅ™iÅ™azenÃ­ `x, y = y, x%y`. Je to dvojÃ­ pÅ™iÅ™azenÃ­, ale nelze jej rozdÄ›lit na dvÄ› pÅ™iÅ™azenÃ­ `x=y` a `y=x%y`, protoÅ¾e druhÃ© pÅ™iÅ™azenÃ­ se po prvnÃ­m zmÄ›nilo na `y=y%y` a tedy y bude pÅ™iÅ™azena 0.  

1. MÅ¯Å¾eme se ptÃ¡t, proÄ to funguje (protoÅ¾e z dvojice na pravÃ© stranÄ› se pÅ™ed pÅ™iÅ™azenÃ­m vytvoÅ™Ã­ nemÄ›nnÃ¡ - konstantnÃ­ dvojice - _tuple_ - a ten se pÅ™i pÅ™iÅ™azenÃ­ "rozbalÃ­" do x a y). 
2. Jak byste takovÃ©to pÅ™iÅ™azenÃ­ rozepsali na jednoduchÃ¡ pÅ™iÅ™azenÃ­, aby to fungovalo?

Toto je uÅ¾ celkem vÃ½konnÃ½ algoritmus, poÄetnÃ­ nÃ¡roÄnost je $\sim \log n$ TeÄ mÅ¯Å¾eme dÄ›lat vÃ­c vÄ›cÃ­, napÅ™Ã­klad spoÄÃ­st Eulerovu funkci pro prvnÃ­ch miliÃ³n ÄÃ­sel a podobnÄ›. 

-----

## Seznamy

```python
>>> cisla = [1,2,3,4,5]
>>> type(cisla)
list
>>> cisla[0] # V Pythonu ÄÃ­slujeme od 0
1
>>> cisla[4] # takÅ¾e poslednÃ­ prvek je poÄet prvkÅ¯ - 1
5
>>> len(cisla) # poÄet prvkÅ¯ je len
5
>>> cisla[-1] # IndexovÃ¡nÃ­ je velmi flexibilnÃ­
5
>>> cisla[1:3]
[2, 3]
>>> cisla[0:5]
[1, 2, 3, 4, 5]
>>> cisla[:3]
[1, 2, 3]
>>> cisla[3:]
[4, 5]
>>> cisla.append(6) # PÅ™idÃ¡nÃ­ novÃ©ho prvku do seznamu
>>> cisla
[1, 2, 3, 4, 5, 6]
```

Seznamy mÅ¯Å¾ou obsahovat rÅ¯znÃ© vÄ›ci:

```python
zaci = ["Honza", "Jakub", "Franta"]
matice = [[1,2,3],[2,3,1]] # NeuÅ¾iteÄnÃ¡ implementace matice
matice[0]
>>> [1,2,3]
matice[1][1] 
>>> 3
>>> [1,2] + [3,4] # aritmetika pro seznamy
[1, 2, 3, 4]
>>> [1,2]*3
[1, 2, 1, 2, 1, 2]
```

 ... ale takÃ© poloÅ¾ky rÅ¯znÃ©ho druhu:

```python
>>> lst = [1,"Peter",True]
>>> lst
[1, 'Peter', True]
>>> del lst[0]
>>> lst
['Peter', True]
>>> 
```

Pozor na kopÃ­rovÃ¡nÃ­ seznamÅ¯:

```python
>>> a = ['jeden', 'dva', 'tri']
>>> b = a
>>> a[0] = 'jedna'
>>> b
['jedna', 'dva', 'tri']
>>> c = [[1,2]]*3
>>> c
[[1, 2], [1, 2], [1, 2]]
>>> c[0][0] = 0
>>> c
[[0, 2], [0, 2], [0, 2]]
```

Seznam umÃ­me lehce setÅ™Ã­dit nebo obrÃ¡tit:

```python
>>> c = [2,4,1,3]
>>> sorted(c)
[1,2,3,4]
>>> reversed[c]
[3,1,4,2]
```

O tÅ™Ã­dÄ›nÃ­ budeme mluvit na nÃ¡sledujÃ­cÃ­m cviÄenÃ­. 

#### Cyklus `for` 

```python
In [9]: cisla = [1,1,2,3,5,8]

In [10]: for cislo in cisla:
    ...:     print(cislo, end = "-")
    ...:
1-1-2-3-5-8-
```

ÄŒasto chceme, aby cyklus probÃ­hal pÅ™es jednoduchou ÄÃ­selnou Å™adu, napÅ™. $1,2,\dots,n$. Na generovÃ¡nÃ­ takovÃ½chto Å™ad slouÅ¾Ã­ funkce `range`:

```python
>>> for i in range(5):
	print(i, end = ' ')
	
0 1 2 3 4 
```

`range` respektuje ÄÃ­slovacÃ­ konvence Pythonu a podporuje jeÅ¡tÄ› dalÅ¡Ã­ argumenty: zaÄÃ¡tek sekvence a krok:

```python
>>> for i in range(2,10,3):
...     print(i)
...
2
5
8
```

Argumenty nemusÃ­ bÃ½t kladnÃ¡ ÄÃ­sla, takÅ¾e mÅ¯Å¾eme lehko iterovat pozpÃ¡tku:

```python
>>> for i in range(9,-1,-1):
---    print(i, end = ' ') 
---
9 8 7 6 5 4 3 2 1 0 >>> 
```

Tedy chceme-li iterovat pozpÃ¡tku pÅ™es `range(n)`, pouÅ¾ijeme `range(n-1,-1, -1)`.Abychom se nespletli, nabÃ­zÃ­ Python elegantnÄ›jÅ¡Ã­ Å™eÅ¡enÃ­:

```python
>>> for i in reversed(range(5)):
	print(i, end = " ")

4 3 2 1 0 
```

a tuto funkci mÅ¯Å¾eme pouÅ¾Ã­t na libovolnÃ½ seznam:

```python
>>> cisla = ["jedna", "dvÄ›", "tÅ™i", "ÄtyÅ™i"]
>>> for cislo in reversed(cisla):
	print(cislo, end = " ")

ÄtyÅ™i tÅ™i dvÄ› jedna 
```

`range(n)` nenÃ­ seznam, i kdyÅ¾ podporuje pÅ™Ã­stup k polÅ¾kÃ¡m pÅ™es index:

```python
>>> range(10)
range(0, 10)
>>> type(range(10))
<class 'range'>
>>> range(10)[-1]
9
>>> list(range(10))
[0,1,2,3,4,5,6,7,8,9]
>>> [i for i in range(10)]
[0,1,2,3,4,5,6,7,8,9]
```

TakÃ© `reversed/seznam)`nenÃ­ seznam, ale reverznÃ­ iterÃ¡tor:

```python
>>> reversed(cisla)
<list_reverseiterator object at 0x000002AE55D45370>
>>> [s for s in reversed(cisla)]
['ÄtyÅ™i', 'tÅ™i', 'dvÄ›', 'jedna']
```

ale `sorted(seznam)` je seznam:

```python
>>> sorted(c)
[1, 2, 3, 4]
```

#### Fibonacciho ÄÃ­sla

$$
Fib(0) = 1,\quad
Fib(1) = 1,\quad
Fib(n) = Fib(n-1) + Fib(n-2),\quad = 2, 3, \dots
$$



*Ãšloha*: VypiÅ¡te prvnÃ­ch n Fibonacciho ÄÃ­sel. 

Ãšvahy: 

- potÅ™ebujeme vÅ¯bec seznam?

```python
# Vypsat prvnich n Fibonacciho cisel
n = int(input())
a = 1
print(a, end = ", ")
b = 1
print(b, end = ", ")
for k in range(3,n+1):
    b, a = b+a, b
    print(b, end = ", ")
```

- MÅ¯Å¾eme zaÄÃ­t seznamem prvnÃ­ch dvou ÄÃ­sel, a pak dopoÄÃ­tÃ¡vat a pÅ™idÃ¡vat na konec dalÅ¡Ã­ ÄÃ­sla:

  ```python
  # Vypsat prvnich n Fibonacciho cisel
  n = int(input())
  fibs = [1,1]
  while len(fibs)<n:
  	fibs.append(fibs[-1] + fibs[-2])
  print(fibs)
  ```

- Nikdy nechcete alokovat pamÄ›Å¥ po malÃ½ch kouscÃ­ch. KdyÅ¾ pÅ™edem vÃ­me dÃ©lku seznamu, je nejlepÅ¡Ã­ zÅ™Ã­dit ho celÃ½ a jenom ho naplnit. 

#### PÅ™Ã­klad: ErastothÃ©novo sÃ­to

*Ãšloha*: NajdÄ›te vÅ¡echna prvoÄÃ­sla menÅ¡Ã­ nebo rovnÃ¡ n.

Ãšvahy:

- MusÃ­me si nÄ›jak pamatovat, kterÃ¡ ÄÃ­sla jsme uÅ¾ vyÅ¡ktrtli a kterÃ¡ nÃ¡m jeÅ¡tÄ› zÅ¯stala. 
- Jedno Å™eÅ¡enÃ­ je, Å¾e vezmeme seznam vÅ¡ech ÄÃ­sel od 2 do n a budeme odstraÅˆovat ty, kterÃ© nejsou prvoÄÃ­sly. To je ale pomalÃ© a v promÄ›nlivÃ©m poli se Å¡patnÄ› iteruje - nenÃ­ snadnÃ© urÄit, kde prÃ¡vÄ› v poli jsme. 
- LepÅ¡Ã­ je vzÃ­t seznam logickÃ½ch hodnot. Index bude ÄÃ­slo, a hodnota bude oznaÄovat, jestli jej zatÃ­m povaÅ¾ujeme za prvoÄÃ­slo anebo uÅ¾ ne. 

```python
# vypiÅ¡ vÅ¡echna prvoÄÃ­sla menÅ¡Ã­ nebo rovnÃ¡ n

n = int(input())

prvocisla = [True]*(n+1) # vÄetnÄ› nuly a n
prvocisla[0] = False
prvocisla[1] = False
for i in range(2,n+1):
    if prvocisla[i]:
        for j in range(i*i, n+1, i):
            prvocisla[j]=False

print("Pocet: ", sum(prvocisla))
for i in range(n+1):
    if prvocisla[i]:
        print(i, end = ', ')
```

-----

#### DalÅ¡Ã­ Ãºkoly

- NajdÄ›te ÄÃ­slo zapsanÃ© samÃ½mi jedniÄkami (v desÃ­tkovÃ© soustavÄ›), kterÃ© je dÄ›litelnÃ© zadanÃ½m K. Jak se vÄas zastavit, kdyÅ¾ neexistuje? 	
- NajdÄ›te ÄÃ­slo mezi 1 a N s co nejvÃ­ce dÄ›liteli.	

**DomÃ¡cÃ­ Ãºkoly na pÅ™Ã­Å¡tÃ­ tÃ½den:**

* Na vstupu ÄÃ­sla, jedno na Å™Ã¡dek, ukonÄenÃ© -1. NajÃ­t druhÃ© nejvÄ›tÅ¡Ã­ ÄÃ­slo
* Na vstupu nezÃ¡pornÃ© celÃ© ÄÃ­slo, vypsat v binÃ¡rnÃ­m tvaru.

- Na vstupu kladnÃ© celÃ© n. Vypsat poÄet PytagorejskÃ½ch trojic s ÄÃ­sly menÅ¡Ã­mi neÅ¾ n.	

##### PomÅ¯cka

Odkud vezmeme posloupnost pro testovÃ¡nÃ­ domÃ¡cÃ­ho Ãºkolu?

```python
from random import randint

low = 0
high = 10
n = 10

print([randint(low, high) for i in range(10)])
```

