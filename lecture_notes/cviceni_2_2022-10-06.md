1. ## ProgramovÃ¡nÃ­ 1 pro matematiky


# 2. cviÄenÃ­, 6-10-2022

###### tags: `Programovani 1 2022`, `Ätvrtek 1`, `Ätvrtek 2`

-----

**Obsah**:

0. FarnÃ­ oznamy
1. OpakovÃ¡nÃ­
2. PÅ™Ã­kaz `if` 
3. PÅ™Ã­kaz `while`
4. Programujeme...

------



### FarnÃ­ oznamy

1. **MateriÃ¡ly k pÅ™ednÃ¡Å¡kÃ¡m** najdete v GitHub repozitÃ¡Å™i https://github.com/PKvasnick/Programovani-1. Najdete tam takÃ© kÃ³d ke cviÄenÃ­m.
   - Soubory si mÅ¯Å¾ete ÄÃ­st pÅ™Ã­mo na GitHubu. Pokud si chcete stÃ¡hnout nebo zkopÃ­rovat kÃ³d, pÅ™epnÄ›te do _Raw_ zobrazenÃ­ (aby se vÃ¡m nezkopÃ­rovaly ÄÃ­sla Å™Ã¡dkÅ¯ a pod.), Ctrl-A + Ctrl-C.
   - Windows: Nainstalujte si aplikaci GitHub Desktop a naklonujte si celÃ½ repozitÃ¡Å™ do svÃ©ho poÄÃ­taÄe: ZelenÃ© tlaÄÃ­tko `Code`, z nabÃ­dky `Open with GitHub Desktop`. 
   - Pokud se v nÄ›jakÃ©m okamÅ¾iku neobejdete bez zÅ™Ã­zenÃ­ konta na GitHubu, zÅ™iÄte si jej. 

2. **DomÃ¡cÃ­ Ãºkoly** Doiterovali jsme se k docela velkÃ© ÃºspÄ›Å¡nosti u jedinÃ©ho Ãºkolu, kterÃ½ jsem zadÃ¡val na pÅ™edchozÃ­m cviÄenÃ­. VÃ­ce v osobitnÃ© ÄÃ¡sti.

   **Pokud jeÅ¡tÄ› nemÃ¡te sprÃ¡vnÃ© Å™eÅ¡enÃ­**, vÄ›zte, Å¾e dostanete jeÅ¡tÄ› nÄ›jakÃ© body i kdyÅ¾ ho odevzdÃ¡te do pÅ™Ã­Å¡tÃ­ stÅ™edy. 

3. **KaÅ¾dÃ©mu vÅ¡e chodÃ­?** - pÅ™iÅ¡el takovÃ½to e-mail, pokud mÃ¡te problÃ©my, prosÃ­m hlaÅ¡te se:

> ZdravÃ­m,
>
> NÄ›kteÅ™Ã­ z nÃ¡s na cviÄenÃ­ch Äelili problÃ©mÅ¯m studentÅ¯ s  nemoÅ¾nostÃ­ se pÅ™ihlÃ¡sit do poÄÃ­taÄÅ¯ v Impactu. ZÃ¡vÄ›ry z vyÅ¡etÅ™ovÃ¡nÃ­  pÅ™Ã­Äin a Å™eÅ¡enÃ­ posÃ­lÃ¡m nÃ­Å¾e:
>
> \1. Kdo nenÃ­ studentem MFF, tak se nemÅ¯Å¾e pÅ™ihlÃ¡sit (systÃ©m  uznÃ¡vÃ¡ pouze jmennÃ½ login a ten studenti jinÃ½ch fakult prÃ½ nemajÃ­).  Å˜eÅ¡enÃ­m je zÅ™Ã­dit jim lokÃ¡lnÃ­ ÃºÄet na MalÃ© StranÄ›. Jana zjistila, Å¾e je  moÅ¾nÃ© napsat email na [simunek@sisal.mff.cuni.cz](javascript:void(window.open('/horde/imp/dynamic.php?page=compose&to=simunek%40sisal.mff.cuni.cz&popup=1','','width=820,height=610,status=1,scrollbars=yes,resizable=yes'))) jmÃ©no s ÄÃ­slem osoby na kartiÄce UK (a pro Ãºplnost i email) a Dr. Å imÅ¯nek jim to zaÅ™Ã­dÃ­. 
>
> \2. Studenti MFF, kteÅ™Ã­ majÃ­ ÃºÄet na MalÃ© StranÄ›, se musÃ­ mÃ­t na pozoru. Tento ÃºÄet mÃ¡ prioritu pÅ™ed pÅ™ihlaÅ¡ovÃ¡nÃ­m pÅ™es CAS. TakÅ¾e  pro pÅ™ihlÃ¡Å¡enÃ­ na poÄÃ­taÄe v Impactu musÃ­! pouÅ¾Ã­t login a heslo z MalÃ©  Strany. Toto platÃ­ i pro toho, kdo si Äasem ÃºÄet na MalÃ© StranÄ› jeÅ¡tÄ›  udÄ›lÃ¡.
>
> \3. Pro pÅ™ihlÃ¡Å¡enÃ­ pomocÃ­ CAS nefunguje ÄÃ­slo osoby. Je nutnÃ© zadat login, kterÃ½ se sklÃ¡dÃ¡ z ÄÃ¡sti pÅ™Ã­jmenÃ­, jmÃ©na, ÄÃ­sla a nÄ›jakÃ½ch  pÃ­smen, typu roskb5am. Pro pÅ™ihlÃ¡Å¡enÃ­ je prÃ½ nutnÃ© pouÅ¾Ã­t malÃ¡ pÃ­smena.
>
> \4. Studenti mohou mÃ­t jeÅ¡tÄ› problÃ©my s pÅ™ihlÃ¡Å¡enÃ­m, pÃ¡Ä na poÄÃ­taÄi mÅ¯Å¾e bÃ½t nastavenÃ¡ anglickÃ¡ klÃ¡vesnice a ne ÄeskÃ¡. 
>
> Pokud mÃ¡te jeÅ¡te jinÃ© postÅ™ehy, nevÃ¡hejte je sdÃ­let.
>
> ZatÃ­m,
>
> Beda Roskovec



-----

### OpakovÃ¡nÃ­

- [x] ZÃ¡kladnÃ­ instalace Pythonu
- [x] ÄŒÃ­sla a Å™etÄ›zce, aritmetickÃ© a logickÃ© operace
- [x] **DomÃ¡cÃ­ Ãºkol:** Konverze `int()`

```python
a = input()
b = input()
print(a, b, a>b)

=============== RESTART: C:\Users\kvasn\Dropbox\Python_MFF\sk.py ===============
2
13
2 13 True
```

```python
a = int(input())
b = int(input())
print(a, b, a>b)

=============== RESTART: C:\Users\kvasn\Dropbox\Python_MFF\sk.py ===============
2
13
2 13 False
```

NejspÃ­Å¡ vÃ¡s nepÅ™ekvapÃ­, Å¾e takÃ© existuje `float()`, `str()` a `bool()`


```{python}
In [3]: int(4.9)
Out[3]: 4

In[4]: int("Petr")
Traceback (most recent call last):
  File "<pyshell#72>", line 1, in <module>
    int("Petr")
ValueError: invalid literal for int() with base 10: 'Petr'

In [5]: round(4.9,0)
Out[5]: 5.0

In [6]: float(5)
Out[6]: 5.0

In [7]: bool(0.5)
Out[7]: True

In [8]: bool(-1.0)
Out[8]: True

In [9]: bool(0.0)
Out[9]: False

In [10]: str(4.6)
Out[10]: '4.6'

In [11]: str(True)
Out[11]: 'True'

In [12]: str(False)
Out[12]: 'False'


```

- [ ] OperÃ¡tory `+,-,*,/,**,//,%, ==, and, or, not`

- [ ] PÅ™iÅ™azenÃ­ `=` a pÅ™iÅ™azenÃ­ s operacÃ­ `Â°+=, -=, *=, /=`, ale takÃ© tÅ™eba `%=` - operÃ¡tor _vymodulenÃ­_, s kterÃ½m se dnes setkÃ¡me.

- [ ] MatematickÃ© funkce z balÃ­ku _math_,  `import math` a pak `math.*`, napÅ™. `math.sin()`.

- [ ] Funkce pro ÄtenÃ­ Å™etÄ›zce ze standardnÃ­ho vstupu `input(vÃ½zva)` a funkce pro tisk do standardnÃ­ho vÃ½stupu `print(objekt1, objekt2, ...)`

  Print podrobnÄ›ji:

  ```python
  print(1,2,3); print(4,5,6)
  1 2 3
  4 5 6
  ```

  Konverze do Å™etÄ›zcovÃ© reprezentace, poloÅ¾ky oddÄ›lenÃ© mezerami, na konci znak novÃ©ho Å™Ã¡dku.

  ```python
  print(1, 2, 3, sep = "-", end = "!!!\n")
  ```

  FormÃ¡tovÃ¡nÃ­ vÃ½stupu:

  ```python
  jmeno = "Petr"
  vaha = 100
  print(jmeno, "vÃ¡Å¾Ã­", vaha, "kilogramÅ¯")
  print(f"{jmeno} vÃ¡Å¾Ã­ {vaha} kilogramÅ¯")
  ```

  

- [ ] PodmÃ­nÄ›nÃ½ pÅ™Ã­kaz 

  ```{python}
  if podmÃ­nka:
     pÅ™Ã­kazy
  ```

- [ ] PÅ™Ã­kaz cyklu

  ```{python}
  while podmÃ­nka:
     pÅ™Ã­kazy
  ```

  kde _pÅ™Ã­kazy_ mÅ¯Å¾ou bÃ½t pÅ™Ã­kazy pÅ™iÅ™azenÃ­, volÃ¡nÃ­ funkce, dalÅ¡Ã­ podmÃ­nÄ›nÃ© pÅ™Ã­kazy nebo pÅ™Ã­kazy cyklu, a dnes se nauÄÃ­me, Å¾e takÃ© pÅ™Ã­kazy `pass` (nedÄ›lej nic), `break` (opuÅ¡tÄ›nÃ­ cyklu) a `continue` (pÅ™echod na dalÅ¡Ã­ iteraci cyklu).

-----

### PÅ™Ã­kaz `if`

ÃšplnÄ›jÅ¡Ã­ syntaxe pÅ™Ã­kazu `if`:

```{python}
if podmÃ­nka:
   pÅ™Ã­kazy
else:			# volitelnÄ›
   pÅ™Ã­kazy
```

VÄ›tev `else` je nepovinnÃ¡; kdyÅ¾ chceme vynechat pÅ™Ã­kazy ve vÄ›tvi `if`, musÃ­me pouÅ¾Ã­t prÃ¡zdnÃ½ pÅ™Ã­kaz `pass`. 

VÄ›tve `elif`: V pÅ™Ã­padÄ› Å™etÄ›zÃ­cÃ­ch pÅ™Ã­kazÅ¯ `if` mÅ¯Å¾eme namÃ­sto konstrukce

```{python}
if podmÃ­nka1:
   pÅ™Ã­kazy
else:
   if podmÃ­nka2:
      pÅ™Ã­kazy
   else:
      pÅ™Ã­kazy
         
```

psÃ¡t

```{python}
if podmÃ­nka1:
   pÅ™Ã­kazy
elif podmÃ­nka2:
   pÅ™Ã­kazy
else:
   pÅ™Ã­kazy
```

coÅ¾ je o nÄ›co pÅ™ehlednÄ›jÅ¡Ã­ - hlavnÄ› dÃ­ky plochÃ©mu (nerostoucÃ­mu) odsazenÃ­.

-----

### PÅ™Ã­kaz `while`

```{python}
while podmÃ­nka:
   pÅ™Ã­kazy
```

PÅ™Ã­kazy pro kontrolu bÄ›hu cyklu:

`break` - v tomto mÃ­stÄ› opustit cyklus a pokraÄovat pÅ™Ã­kazem, nÃ¡sledujÃ­cÃ­m za cyklem

`continue` - v tomto mÃ­stÄ› pÅ™ejÃ­t na dalÅ¡Ã­ iteraci cyklu (tedy na testovÃ¡nÃ­ podmÃ­nky)

NekoneÄnÃ½ cyklus: podmÃ­nka stÃ¡le platÃ­, a o ukonÄenÃ­ cyklu rozhodneme v tÄ›le za pouÅ¾itÃ­ pÅ™Ã­kazu `break`:

```{python}
while True:
   pÅ™Ã­kazy
   if podmÃ­nka:
      break
```

PÅ™Ã­kaz `while` mÃ¡ takÃ© volitelnou vÃ©tev `else`. PÅ™Ã­kazy v tÃ©to vÄ›tvi se vykonajÃ­, pokud cyklus Å™Ã¡dnÄ› skonÄÃ­ (tedy ne v pÅ™Ã­padÄ› opuÅ¡tÄ›nÃ­ cyklu pÅ™Ã­kazem `break`).

```{python}
while podmÃ­nka:
   pÅ™Ã­kazy1
else:
   pÅ™Ã­kazy2
```

-----

### PÅ™Ã­klady

#### Test prvoÄÃ­sel

Chceme otestovat, zda je ÄÃ­slo $n$ ze vstupu prvoÄÃ­slo.

Metoda: U vÅ¡ech ÄÃ­sel $d<n$ provÄ›Å™Ã­m, zda jsou dÄ›liteli $n$.

```{python}
#!/usr/bin/env python3

# Otestuje, zda ÄÃ­slo je prvoÄÃ­slem

n = int(input())
d = 2
mam_delitele = False

while d < n:
    if n%d == 0:
        print("ÄŒÃ­slo", n, "je dÄ›litelnÃ©", d)
        mam_delitele = True
        break
    d += 1

if not mam_delitele:
    print("ÄŒÃ­slo", n, "je prvoÄÃ­slo")
```

To nenÃ­ nijak zvlÃ¡Å¡Å¥ efektivnÃ­ metoda, ale to nÃ¡m nevadÃ­, my jsme celÃ­ rÃ¡di, Å¾e umÃ­me napsat nÄ›co, co v zÃ¡sadÄ› funguje. 

PojÄme opatrnÄ› vylepÅ¡ovat. ZÃ¡sadnÃ­ vylepÅ¡enÃ­ kÃ³du by bylo, kdybychom "nahÃ½" cyklus `while` umÄ›li celÃ½ zapouzdÅ™it do jedinÃ©ho pÅ™Ã­kazu. 

ğŸ˜ _PokroÄilÃ© kolegy poprosÃ­m o tvar onoho jedinÃ©ho pÅ™Ã­kazu._

Asi prvnÃ­ vÄ›c, kterÃ¡ nÃ¡m vadÃ­, je stavovÃ¡ promÄ›nnÃ¡ `mam_delitele`. A tÃ© se v prvnÃ­m kroku zbavÃ­me za pouÅ¾itÃ­ vÄ›tve `else`:

```{python}
#!/usr/bin/env python3

# Otestuje, zda ÄÃ­slo je prvoÄÃ­slem (2. pokus)

n = int(input())
d = 2

while d < n:
    if n%d == 0:
        print("ÄŒÃ­slo", n, "je dÄ›litelnÃ©", d)
        break
    d += 1
else:
    print("ÄŒÃ­slo", n, "je prvoÄÃ­slo")
```

Jak bychom mohli dÃ¡l vylepÅ¡it nÃ¡Å¡ test?

PopÅ™emÃ½Å¡lÃ­me, a zatÃ­m vymyslÃ­me, jak bychom vypsali vÅ¡echna provÄÃ­sla menÅ¡Ã­ nebo rovnÃ¡ $n$. NejjednoduÅ¡Å¡Ã­ metoda bude projÃ­t vÅ¡echna ÄÃ­sla od 2 do $n$, u kaÅ¾dÃ©ho rozhodnout, zda je prvoÄÃ­slem, a jestli ano, vypsat ho. 

```python
#!/usr/bin/env python3
# VypÃ­Å¡e vÅ¡echna prvoÄÃ­sla od 1 do n

n = int(input())

x = 2
while x <= n:
    d = 2
    while d < x:
        if x%d == 0:
            break
        d += 1
    else:
        print(x)

    x += 1

```

Optimalizace je v tomto pÅ™Ã­padÄ› jeÅ¡tÄ› vÃ­ce nasnadÄ›, jenomÅ¾e si zatÃ­m neumÃ­me pamatovat vÄ›ci - napÅ™Ã­klad vÅ¡echny prvoÄÃ­sla, kterÃ© jsme dosud nalezli.

ğŸ˜ _PokroÄilÃ© kolegy_ poprosÃ­m o optimalizovanÃ½ algoritmus, napÅ™. Erastothenovo sÃ­to. 

-----



### EuklidÅ¯v algoritmus

ZÃ¡kladnÃ­ verze s odeÄÃ­tÃ¡nÃ­m: $x>y: \gcd(x,y) = \gcd(x-y,y)$

```python
#!/usr/bin/env python3
# NejvÄ›tÅ¡Ã­ spoleÄnÃ½ dÄ›litel: EuklidÅ¯v algoritmus s odÄÃ­tÃ¡nÃ­m

x = int(input())
y = int(input())

while x != y:
    if x > y:
        x -= y
    else:
        y -= x

print(x)

```

Pokud je jedno z ÄÃ­sel o hodnÄ› menÅ¡Ã­ neÅ¾ druhÃ©, moÅ¾nÃ¡ budeme opakovanÄ› odeÄÃ­tat, a to nÃ¡s spomaluje (nÃ¡roÄnost algoritmu je lineÃ¡rnÃ­ v n). Je proto lepÅ¡Ã­ v jednom kroku odeÄÃ­tat kolikrÃ¡t to jde: _odeÄÃ­tÃ¡nÃ­ nahradÃ­me operacÃ­ modulo_:

```python
#!/usr/bin/env python3
# NejvÄ›tÅ¡Ã­ spoleÄnÃ½ dÄ›litel: EuklidÅ¯v algoritmus s modulem

x = int(input())
y = int(input())

while x > 0 and y > 0:
    if x > y:
        x %= y
    else:
        y %= x

if x > 0:
    print(x)
else:
    print(y)
```

ProtoÅ¾e `x % y < y`, po kaÅ¾dÃ© operaci modulo vÃ­me, jakÃ¡ je vzÃ¡jemnÃ¡ velikost x a y. KÃ³d tedy mÅ¯Å¾eme vÃ½raznÄ› zdokonalit:

```python
#!/usr/bin/env python3
# NejvÄ›tÅ¡Ã­ spoleÄnÃ½ dÄ›litel: EuklidÅ¯v algoritmus s pÃ¡r triky navÃ­c

x = int(input())
y = int(input())

while y > 0:
    x, y = y, x%y

print(x)
```

Tady si vÅ¡imneme pÅ™iÅ™azenÃ­ `x, y = y, x%y`. Je to dvojÃ­ pÅ™iÅ™azenÃ­, ale nelze jej rozdÄ›lit na dvÄ› pÅ™iÅ™azenÃ­ `x=y` a `y=x%y`, protoÅ¾e druhÃ© pÅ™iÅ™azenÃ­ se po prvnÃ­m zmÄ›nilo na `y=y%y` a tedy y bude pÅ™iÅ™azena 0.  

1. MÅ¯Å¾eme se ptÃ¡t, proÄ to funguje (protoÅ¾e z dvojice na pravÃ© stranÄ› se pÅ™ed pÅ™iÅ™azenÃ­m vytvoÅ™Ã­ nemÄ›nnÃ¡ - konstantnÃ­ dvojice - _tuple_ - a ten se pÅ™i pÅ™iÅ™azenÃ­ "rozbalÃ­" do x a y). 
2. Jak byste takovÃ©to pÅ™iÅ™azenÃ­ rozepsali na jednoduchÃ¡ pÅ™iÅ™azenÃ­, aby to fungovalo?

Toto je uÅ¾ celkem vÃ½konnÃ½ algoritmus, poÄetnÃ­ nÃ¡roÄnost je $\sim \log n$ TeÄ mÅ¯Å¾eme dÄ›lat vÃ­c vÄ›cÃ­, napÅ™Ã­klad spoÄÃ­st Eulerovu funkci pro prvnÃ­ch miliÃ³n ÄÃ­sel a podobnÄ›. 

-----

#### SouÄet posloupnosti ÄÃ­sel

```python
#!/usr/bin/env python3

# NaÄteme ze vstupu posloupnost ÄÃ­sel, ukonÄenou -1.
# VypÃ­Å¡eme jejich souÄet. 

s = 0
while True:
    n = int(input())
    if n == -1:
        break
    s += n
print(s)
```

ProÄ nemÅ¯Å¾eme na konci jenom stisknout Enter a nezadat nic?

ğŸ˜ _PokroÄilÃ© kolegy poprosÃ­m_

- o variantu se stiskem Enter 
- a pro vypsÃ¡nÃ­ aritmetickÃ©ho prÅ¯mÄ›ru a standardnÃ­ odchylky._

#### DruhÃ© nejvÄ›tÅ¡Ã­ ÄÃ­slo posloupnosti

NaÄtÄ›te ze vstupu posloupnost ÄÃ­sel ukonÄenou -1. Pak vypiÅ¡te 

- druhÃ© nejvÄ›tÅ¡Ã­ ÄÃ­slo posloupnosti
- jeho polohu v posloupnosti

Abychom pochopili, jak to udÄ›lat, pÅ™emÃ½Å¡lÃ­me v termÃ­nech stavu naÅ¡eho pÃ¡trÃ¡nÃ­ po druhÃ©m nejvÄ›tÅ¡Ã­m ÄÃ­sle. Abychom sprÃ¡vnÄ› naloÅ¾ili s novÃ½m ÄÃ­slem, musÃ­me si pamatovat aktuÃ¡lnÄ› nejvÄ›tÅ¡Ã­ a druhÃ© nejvÄ›tÅ¡Ã­ ÄÃ­slo posloupnosti $m_1$ a $m_2$. KdyÅ¾ nÃ¡m pÅ™ijde novÃ½ Älen posloupnosti $m$, musÃ­me tento stav - tedy ÄÃ­sla  $m_1$ a $m_2$ - aktualizovat podle toho, jakÃ¡ je jeho velikost. Pokud pÅ™ijde $m=-1$, vypÃ­Å¡eme $m_2$. 

```python
#!/usr/bin/env python3
# NaÄÃ­tÃ¡ ÄÃ­sla ze vstupu ukonÄenÃ¡ -1,
# vypÃ­Å¡e druhÃ© nejvÄ›tÅ¡Ã­ z nich

m1 = 0      # ZatÃ­m nejvÄ›tÅ¡Ã­ ÄÃ­slo
m2 = 0      # ZatÃ­m druhÃ© nejvÄ›tÅ¡Ã­

while True:
    n = int(input())
    if n == -1:
        break

    if n >= m1:
        m1, m2 = n, m1
    elif n >= m2:
        m2 = n

print(m2)
```

-----

#### DalÅ¡Ã­ Ãºlohy

DalÅ¡Ã­ Ãºkoly: 	

- SpoÄÃ­tejte, kolik mÃ¡ zadanÃ© ÄÃ­slo cifer. 	
- NajdÄ›te ÄÃ­slo zapsanÃ© samÃ½mi jedniÄkami (v desÃ­tkovÃ© soustavÄ›), kterÃ© je dÄ›litelnÃ© zadanÃ½m K. Jak se vÄas zastavit, kdyÅ¾ neexistuje? 	
- NajdÄ›te ÄÃ­slo mezi 1 a N s co nejvÃ­ce dÄ›liteli.	

**DomÃ¡cÃ­ Ãºkoly na pÅ™Ã­Å¡tÃ­ tÃ½den:**

* SpoÄÃ­st a vypsat poÄet cifer zadanÃ©ho celÃ©ho ÄÃ­sla
* Vypsat zadanÃ© ÄÃ­slo jako souÄin prvoÄinitelÅ¯ 

- VypoÄtÄ›te Eulerovu funkci (*Euler's totient function*) $\phi(n)$, kterÃ¡ je rovna poÄtu s $n$ nesoudÄ›lnÃ½ch (*relatively coprime*) ÄÃ­sel menÅ¡Ã­ch neÅ¾ $n$.
