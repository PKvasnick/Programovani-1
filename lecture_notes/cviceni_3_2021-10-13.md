## `Programování` 1 pro matematiky

# 3. cvičení, 13,14-10-2021

###### tags: `Programovani 1 2021`, `středa`, `čtvrtek`

-----

**Obsah**:

0. Farní oznamy
1. Opakování
2. Seznamy
4. Programujeme...



### Farní oznamy

1. **Materiály k přednáškám** najdete v GitHub repozitáři https://github.com/PKvasnick/Programovani-1. Najdete tam také kód ke cvičením.
2. **Domácí úkoly** Tady se omlouvám, pral jsem se s ReCodExem, abych vám mohl zadat smysluplné domácí úkoly, ale nepovedlo se. Když budete psát víc kódu, budou snad omezení ReCodExu méně obtěžující. 
3. **Každému vše chodí?** 

------

### Opakování

- [ ] **`if-elif-else`:**
```{python}
if podmínka1:
   příkazy1
elif podmínka2:
   příkazy2
else:		
   příkazy3
```
- [ ] **Prázdný příkaz `pass`**
- [ ] **Cyklus `while`:**
```{python}
while podmínka:
   příkazy
```
Příkazy pro kontrolu běhu cyklu:

`break` - v tomto místě opustit cyklus a pokračovat příkazem, následujícím za cyklem

`continue` - v tomto místě přejít na další iteraci cyklu (tedy na testování podmínky)

Větev `else`:

```{python}
while podmínka:
   příkazy
else
   příkazy-jen-jestli-proběhl-celý-cyklus
```


- [ ] **Vícenásobná přiřazení: **

  `a, b = b, a%b` (Krok modulícího Eulerova algoritmu)

   `a,b = a+b,a` (Čeho je toto krok?)

------
### Seznamy

```python
>>> cisla = [1,2,3,4,5]
>>> type(cisla)
list
>>> cisla[0] # V Pythonu číslujeme od 0
1
>>> cisla[4] # takže poslední prvek je počet prvků - 1
5
>>> len(cisla) # počet prvků je len
5
>>> cisla[-1] # Indexování je velmi flexibilní
5
>>> cisla[1:3]
[2, 3]
>>> cisla[0:5]
[1, 2, 3, 4, 5]
>>> cisla[:3]
[1, 2, 3]
>>> cisla[3:]
[4, 5]
>>> cisla.append(6) # Přidání nového prvku do seznamu
>>> cisla
[1, 2, 3, 4, 5, 6]
```

Seznamy můžou obsahovat různé věci:

```python
zaci = ["Honza", "Jakub", "Franta"]
matice = [[1,2,3],[2,3,1]] # Neužitečná implementace matice
matice[0]
>>> [1,2,3]
matice[1][1] 
>>> 3
>>> [1,2] + [3,4] # aritmetika pro seznamy
[1, 2, 3, 4]
>>> [1,2]*3
[1, 2, 1, 2, 1, 2]
```

I jeden seznam může obsahovat položky různého druhu:

```python
>>> lst = [1,"Peter",True]
>>> lst
[1, 'Peter', True]
```

x 

#### Cyklus `for` 

```python
In [9]: cisla = [1,1,2,3,5,8]

In [10]: for cislo in cisla:
    ...:     print(cislo, end = "-")
    ...:
1-1-2-3-5-8-
```

Často chceme, aby cyklus probíhal pro jednoduchou číselnou řadu, např. $1,2,\dots,n$. Na generování takovýchto řad slouží funkce `range`:

```python
>>> for i in range(5):
---    print(i)
---    
0    
1
2
3
4¨
```

`range` respektuje číslovací konvence Pythonu a podporuje ještě další argumenty: začátek sekvence a krok:

```python
>>> for i in range(2,10,3):
...     print(i)
...
2
5
8
```

Argumenty nemusí být kladná čísla, takže můžeme lehko iterovat pozpátku:

```python
>>> for i in range(9,-1,-1):
---    print(i, end = ' ') 
---
9 8 7 6 5 4 3 2 1 0 >>> 
```

`range(n)` není seznam, i když podporuje přístup k položkám přes index:

```python
>>> type(range(10))
<class 'range'>
>>> range(10)[-1]
9
>>> list(range(10))
[0,1,2,3,4,5,6,7,8,9]
>>> [i for i in range(10)]
[0,1,2,3,4,5,6,7,8,9]
```



-----

### Příklady

#### Test prvočísel

Chceme otestovat, zda je číslo $n$ ze vstupu prvočíslo.

Metoda: U všech čísel $d<n$ prověřím, zda jsou děliteli $n$.

```{python}
#!/usr/bin/env python3

# Otestuje, zda číslo je prvočíslem

n = int(input())
d = 2
mam_delitele = False

while d < n:
    if n%d == 0:
        print("Číslo", n, "je dělitelné", d)
        mam_delitele = True
        break
    d += 1

if not mam_delitele:
    print("Číslo", n, "je prvočíslo")
```

To není nijak zvlášť efektivní metoda, ale to nám nevadí, my jsme celí rádi, že umíme napsat něco, co v zásadě funguje. 

Pojďme opatrně vylepšovat. Zásadní vylepšení kódu by bylo, kdybychom "nahý" cyklus `while` uměli celý zapouzdřit do jediného příkazu. 

😎 _Pokročilé kolegy poprosím o tvar onoho jediného příkazu._

Asi první věc, která nám vadí, je stavová proměnná `mam_delitele`. A té se v prvním kroku zbavíme za použití větve `else`:

```{python}
#!/usr/bin/env python3

# Otestuje, zda číslo je prvočíslem (2. pokus)

n = int(input())
d = 2

while d < n:
    if n%d == 0:
        print("Číslo", n, "je dělitelné", d)
        break
    d += 1
else:
    print("Číslo", n, "je prvočíslo")
```

Jak bychom mohli dál vylepšit náš test?

Popřemýšlíme, a zatím vymyslíme, jak bychom vypsali všechna provčísla menší nebo rovná $n$. Nejjednodušší metoda bude projít všechna čísla od 2 do $n$, u každého rozhodnout, zda je prvočíslem, a jestli ano, vypsat ho. 

```python
#!/usr/bin/env python3
# Vypíše všechna prvočísla od 1 do n

n = int(input())

x = 2
while x <= n:
    d = 2
    while d < x:
        if x%d == 0:
            break
        d += 1
    else:
        print(x)

    x += 1

```

Optimalizace je v tomto případě ještě více nasnadě, jenomže si zatím neumíme pamatovat věci - například všechny prvočísla, které jsme dosud nalezli.

😎 _Pokročilé kolegy_ poprosím o algoritmus s memoizací a/anebo Erastothenovo síto. 

-----



### Euklidův algoritmus

Základní verze s odečítáním: $x>y: \gcd(x,y) = \gcd(x-y,y)$

```python
#!/usr/bin/env python3
# Největší společný dělitel: Euklidův algoritmus s odčítáním

x = int(input())
y = int(input())

while x != y:
    if x > y:
        x -= y
    else:
        y -= x

print(x)

```

Pokud je jedno z čísel o hodně menší než druhé, možná budeme opakovaně odečítat, a to nás spomaluje (náročnost algoritmu je lineární v n). Je proto lepší v jednom kroku odečítat kolikrát to jde: _odečítání nahradíme operací modulo_:

```python
#!/usr/bin/env python3
# Největší společný dělitel: Euklidův algoritmus s modulem

x = int(input())
y = int(input())

while x > 0 and y > 0:
    if x > y:
        x %= y
    else:
        y %= x

if x > 0:
    print(x)
else:
    print(y)
```

Protože `x % y < y`, po každé operaci modulo víme, jaká je vzájemná velikost x a y. Kód tedy můžeme výrazně zdokonalit:

```python
#!/usr/bin/env python3
# Největší společný dělitel: Euklidův algoritmus s pár triky navíc

x = int(input())
y = int(input())

while y > 0:
    x, y = y, x%y

print(x)
```

Tady si všimneme přiřazení `x, y = y, x%y`. Je to dvojí přiřazení, ale nelze jej rozdělit na dvě přiřazení `x=y` a `y=x%y`, protože druhé přiřazení se po prvním změnilo na `y=y%y` a tedy y bude přiřazena 0.  

1. Můžeme se ptát, proč to funguje (protože z dvojice na pravé straně se před přiřazením vytvoří neměnná - konstantní dvojice - _tuple_ - a ten se při přiřazení "rozbalí" do x a y). 
2. Jak byste takovéto přiřazení rozepsali na jednoduchá přiřazení, aby to fungovalo?

Toto je už celkem výkonný algoritmus, početní náročnost je $\sim \log n$ Teď můžeme dělat víc věcí, například spočíst Eulerovu funkci pro prvních milión čísel a podobně. 

-----

#### Součet posloupnosti čísel

```python
#!/usr/bin/env python3

# Načteme ze vstupu posloupnost čísel, ukončenou -1.
# Vypíšeme jejich součet. 

s = 0
while True:
    n = int(input())
    if n == -1:
        break
    s += n
print(s)
```

Proč nemůžeme na konci jenom stisknout Enter a nezadat nic?

😎 _Pokročilé kolegy poprosím_

- o variantu se stiskem Enter 
- a pro vypsání aritmetického průměru a standardní odchylky._

#### Druhé největší číslo posloupnosti

Načtěte ze vstupu posloupnost čísel ukončenou -1. Pak vypište 

- druhé největší číslo posloupnosti
- jeho polohu v posloupnosti

Abychom pochopili, jak to udělat, přemýšlíme v termínech stavu našeho pátrání po druhém největším čísle. Abychom správně naložili s novým číslem, musíme si pamatovat aktuálně největší a druhé největší číslo posloupnosti $m_1$ a $m_2$. Když nám přijde nový člen posloupnosti $m$, musíme tento stav - tedy čísla  $m_1$ a $m_2$ - aktualizovat podle toho, jaká je jeho velikost. Pokud přijde $m=-1$, vypíšeme $m_2$. 

```python
#!/usr/bin/env python3
# Načítá čísla ze vstupu ukončená -1,
# vypíše druhé největší z nich

m1 = 0      # Zatím největší číslo
m2 = 0      # Zatím druhé největší

while True:
    n = int(input())
    if n == -1:
        break

    if n >= m1:
        m1, m2 = n, m1
    elif n >= m2:
        m2 = n

print(m2)
```

-----

#### Další úlohy

Další úkoly: 	

- Spočítejte, kolik má zadané číslo cifer. 	
- Najděte číslo zapsané samými jedničkami (v desítkové soustavě), které je dělitelné zadaným K. Jak se včas zastavit, když neexistuje? 	
- Najděte číslo mezi 1 a N s co nejvíce děliteli.	
- Vypočtěte Eulerovu funkci (*Euler's totient function*) $\phi(n)$, která je rovna počtu s $n$ nesoudělných (*relatively coprime*) čísel menších než $n$.