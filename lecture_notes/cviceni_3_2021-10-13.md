## `Programov치n칤` 1 pro matematiky

# 3. cvi캜en칤, 13,14-10-2021

###### tags: `Programovani 1 2021`, `st콏eda`, `캜tvrtek`

-----

**Obsah**:

0. Farn칤 oznamy
1. Opakov치n칤
2. Seznamy
4. Programujeme...



### Farn칤 oznamy

1. **Materi치ly k p콏edn치코k치m** najdete v GitHub repozit치콏i https://github.com/PKvasnick/Programovani-1. Najdete tam tak칠 k칩d ke cvi캜en칤m.
2. **Dom치c칤 칰koly** Tady se omlouv치m, pral jsem se s ReCodExem, abych v치m mohl zadat smyslupln칠 dom치c칤 칰koly, ale nepovedlo se. Kdy budete ps치t v칤c k칩du, budou snad omezen칤 ReCodExu m칠n캩 obt캩쬿j칤c칤. 
3. **Ka쬯칠mu v코e chod칤?** 

------

### Opakov치n칤

- [ ] **`if-elif-else`:**
```{python}
if podm칤nka1:
   p콏칤kazy1
elif podm칤nka2:
   p콏칤kazy2
else:		
   p콏칤kazy3
```
- [ ] **Pr치zdn칳 p콏칤kaz `pass`**
- [ ] **Cyklus `while`:**
```{python}
while podm칤nka:
   p콏칤kazy
```
P콏칤kazy pro kontrolu b캩hu cyklu:

`break` - v tomto m칤st캩 opustit cyklus a pokra캜ovat p콏칤kazem, n치sleduj칤c칤m za cyklem

`continue` - v tomto m칤st캩 p콏ej칤t na dal코칤 iteraci cyklu (tedy na testov치n칤 podm칤nky)

V캩tev `else`:

```{python}
while podm칤nka:
   p콏칤kazy
else
   p콏칤kazy-jen-jestli-prob캩hl-cel칳-cyklus
```


- [ ] **V칤cen치sobn치 p콏i콏azen칤: **

  `a, b = b, a%b` (Krok modul칤c칤ho Eulerova algoritmu)

   `a,b = a+b,a` (캛eho je toto krok?)

------
### Seznamy

```python
>>> cisla = [1,2,3,4,5]
>>> type(cisla)
list
>>> cisla[0] # V Pythonu 캜칤slujeme od 0
1
>>> cisla[4] # tak쬰 posledn칤 prvek je po캜et prvk콢 - 1
5
>>> len(cisla) # po캜et prvk콢 je len
5
>>> cisla[-1] # Indexov치n칤 je velmi flexibiln칤
5
>>> cisla[1:3]
[2, 3]
>>> cisla[0:5]
[1, 2, 3, 4, 5]
>>> cisla[:3]
[1, 2, 3]
>>> cisla[3:]
[4, 5]
>>> cisla.append(6) # P콏id치n칤 nov칠ho prvku do seznamu
>>> cisla
[1, 2, 3, 4, 5, 6]
```

Seznamy m콢쬺u obsahovat r콢zn칠 v캩ci:

```python
zaci = ["Honza", "Jakub", "Franta"]
matice = [[1,2,3],[2,3,1]] # Neu쬴te캜n치 implementace matice
matice[0]
>>> [1,2,3]
matice[1][1] 
>>> 3
>>> [1,2] + [3,4] # aritmetika pro seznamy
[1, 2, 3, 4]
>>> [1,2]*3
[1, 2, 1, 2, 1, 2]
```

I jeden seznam m콢쬰 obsahovat polo쬶y r콢zn칠ho druhu:

```python
>>> lst = [1,"Peter",True]
>>> lst
[1, 'Peter', True]
```

x 

#### Cyklus `for` 

```python
In [9]: cisla = [1,1,2,3,5,8]

In [10]: for cislo in cisla:
    ...:     print(cislo, end = "-")
    ...:
1-1-2-3-5-8-
```

캛asto chceme, aby cyklus prob칤hal pro jednoduchou 캜칤selnou 콏adu, nap콏. $1,2,\dots,n$. Na generov치n칤 takov칳chto 콏ad slou쮂 funkce `range`:

```python
>>> for i in range(5):
---    print(i)
---    
0    
1
2
3
4춷
```

`range` respektuje 캜칤slovac칤 konvence Pythonu a podporuje je코t캩 dal코칤 argumenty: za캜치tek sekvence a krok:

```python
>>> for i in range(2,10,3):
...     print(i)
...
2
5
8
```

Argumenty nemus칤 b칳t kladn치 캜칤sla, tak쬰 m콢쬰me lehko iterovat pozp치tku:

```python
>>> for i in range(9,-1,-1):
---    print(i, end = ' ') 
---
9 8 7 6 5 4 3 2 1 0 >>> 
```

`range(n)` nen칤 seznam, i kdy podporuje p콏칤stup k polo쬶치m p콏es index:

```python
>>> type(range(10))
<class 'range'>
>>> range(10)[-1]
9
>>> list(range(10))
[0,1,2,3,4,5,6,7,8,9]
>>> [i for i in range(10)]
[0,1,2,3,4,5,6,7,8,9]
```



-----

### P콏칤klady

#### Test prvo캜칤sel

Chceme otestovat, zda je 캜칤slo $n$ ze vstupu prvo캜칤slo.

Metoda: U v코ech 캜칤sel $d<n$ prov캩콏칤m, zda jsou d캩liteli $n$.

```{python}
#!/usr/bin/env python3

# Otestuje, zda 캜칤slo je prvo캜칤slem

n = int(input())
d = 2
mam_delitele = False

while d < n:
    if n%d == 0:
        print("캛칤slo", n, "je d캩liteln칠", d)
        mam_delitele = True
        break
    d += 1

if not mam_delitele:
    print("캛칤slo", n, "je prvo캜칤slo")
```

To nen칤 nijak zvl치코콘 efektivn칤 metoda, ale to n치m nevad칤, my jsme cel칤 r치di, 쬰 um칤me napsat n캩co, co v z치sad캩 funguje. 

Poj캞me opatrn캩 vylep코ovat. Z치sadn칤 vylep코en칤 k칩du by bylo, kdybychom "nah칳" cyklus `while` um캩li cel칳 zapouzd콏it do jedin칠ho p콏칤kazu. 

游땙 _Pokro캜il칠 kolegy popros칤m o tvar onoho jedin칠ho p콏칤kazu._

Asi prvn칤 v캩c, kter치 n치m vad칤, je stavov치 prom캩nn치 `mam_delitele`. A t칠 se v prvn칤m kroku zbav칤me za pou쬴t칤 v캩tve `else`:

```{python}
#!/usr/bin/env python3

# Otestuje, zda 캜칤slo je prvo캜칤slem (2. pokus)

n = int(input())
d = 2

while d < n:
    if n%d == 0:
        print("캛칤slo", n, "je d캩liteln칠", d)
        break
    d += 1
else:
    print("캛칤slo", n, "je prvo캜칤slo")
```

Jak bychom mohli d치l vylep코it n치코 test?

Pop콏em칳코l칤me, a zat칤m vymysl칤me, jak bychom vypsali v코echna prov캜칤sla men코칤 nebo rovn치 $n$. Nejjednodu코코칤 metoda bude proj칤t v코echna 캜칤sla od 2 do $n$, u ka쬯칠ho rozhodnout, zda je prvo캜칤slem, a jestli ano, vypsat ho. 

```python
#!/usr/bin/env python3
# Vyp칤코e v코echna prvo캜칤sla od 1 do n

n = int(input())

x = 2
while x <= n:
    d = 2
    while d < x:
        if x%d == 0:
            break
        d += 1
    else:
        print(x)

    x += 1

```

Optimalizace je v tomto p콏칤pad캩 je코t캩 v칤ce nasnad캩, jenom쬰 si zat칤m neum칤me pamatovat v캩ci - nap콏칤klad v코echny prvo캜칤sla, kter칠 jsme dosud nalezli.

游땙 _Pokro캜il칠 kolegy_ popros칤m o algoritmus s memoizac칤 a/anebo Erastothenovo s칤to. 

-----



### Euklid콢v algoritmus

Z치kladn칤 verze s ode캜칤t치n칤m: $x>y: \gcd(x,y) = \gcd(x-y,y)$

```python
#!/usr/bin/env python3
# Nejv캩t코칤 spole캜n칳 d캩litel: Euklid콢v algoritmus s od캜칤t치n칤m

x = int(input())
y = int(input())

while x != y:
    if x > y:
        x -= y
    else:
        y -= x

print(x)

```

Pokud je jedno z 캜칤sel o hodn캩 men코칤 ne druh칠, mo쬹치 budeme opakovan캩 ode캜칤tat, a to n치s spomaluje (n치ro캜nost algoritmu je line치rn칤 v n). Je proto lep코칤 v jednom kroku ode캜칤tat kolikr치t to jde: _ode캜칤t치n칤 nahrad칤me operac칤 modulo_:

```python
#!/usr/bin/env python3
# Nejv캩t코칤 spole캜n칳 d캩litel: Euklid콢v algoritmus s modulem

x = int(input())
y = int(input())

while x > 0 and y > 0:
    if x > y:
        x %= y
    else:
        y %= x

if x > 0:
    print(x)
else:
    print(y)
```

Proto쬰 `x % y < y`, po ka쬯칠 operaci modulo v칤me, jak치 je vz치jemn치 velikost x a y. K칩d tedy m콢쬰me v칳razn캩 zdokonalit:

```python
#!/usr/bin/env python3
# Nejv캩t코칤 spole캜n칳 d캩litel: Euklid콢v algoritmus s p치r triky nav칤c

x = int(input())
y = int(input())

while y > 0:
    x, y = y, x%y

print(x)
```

Tady si v코imneme p콏i콏azen칤 `x, y = y, x%y`. Je to dvoj칤 p콏i콏azen칤, ale nelze jej rozd캩lit na dv캩 p콏i콏azen칤 `x=y` a `y=x%y`, proto쬰 druh칠 p콏i콏azen칤 se po prvn칤m zm캩nilo na `y=y%y` a tedy y bude p콏i콏azena 0.  

1. M콢쬰me se pt치t, pro캜 to funguje (proto쬰 z dvojice na prav칠 stran캩 se p콏ed p콏i콏azen칤m vytvo콏칤 nem캩nn치 - konstantn칤 dvojice - _tuple_ - a ten se p콏i p콏i콏azen칤 "rozbal칤" do x a y). 
2. Jak byste takov칠to p콏i콏azen칤 rozepsali na jednoduch치 p콏i콏azen칤, aby to fungovalo?

Toto je u celkem v칳konn칳 algoritmus, po캜etn칤 n치ro캜nost je $\sim \log n$ Te캞 m콢쬰me d캩lat v칤c v캩c칤, nap콏칤klad spo캜칤st Eulerovu funkci pro prvn칤ch mili칩n 캜칤sel a podobn캩. 

-----

#### Sou캜et posloupnosti 캜칤sel

```python
#!/usr/bin/env python3

# Na캜teme ze vstupu posloupnost 캜칤sel, ukon캜enou -1.
# Vyp칤코eme jejich sou캜et. 

s = 0
while True:
    n = int(input())
    if n == -1:
        break
    s += n
print(s)
```

Pro캜 nem콢쬰me na konci jenom stisknout Enter a nezadat nic?

游땙 _Pokro캜il칠 kolegy popros칤m_

- o variantu se stiskem Enter 
- a pro vyps치n칤 aritmetick칠ho pr콢m캩ru a standardn칤 odchylky._

#### Druh칠 nejv캩t코칤 캜칤slo posloupnosti

Na캜t캩te ze vstupu posloupnost 캜칤sel ukon캜enou -1. Pak vypi코te 

- druh칠 nejv캩t코칤 캜칤slo posloupnosti
- jeho polohu v posloupnosti

Abychom pochopili, jak to ud캩lat, p콏em칳코l칤me v term칤nech stavu na코eho p치tr치n칤 po druh칠m nejv캩t코칤m 캜칤sle. Abychom spr치vn캩 nalo쬴li s nov칳m 캜칤slem, mus칤me si pamatovat aktu치ln캩 nejv캩t코칤 a druh칠 nejv캩t코칤 캜칤slo posloupnosti $m_1$ a $m_2$. Kdy n치m p콏ijde nov칳 캜len posloupnosti $m$, mus칤me tento stav - tedy 캜칤sla  $m_1$ a $m_2$ - aktualizovat podle toho, jak치 je jeho velikost. Pokud p콏ijde $m=-1$, vyp칤코eme $m_2$. 

```python
#!/usr/bin/env python3
# Na캜칤t치 캜칤sla ze vstupu ukon캜en치 -1,
# vyp칤코e druh칠 nejv캩t코칤 z nich

m1 = 0      # Zat칤m nejv캩t코칤 캜칤slo
m2 = 0      # Zat칤m druh칠 nejv캩t코칤

while True:
    n = int(input())
    if n == -1:
        break

    if n >= m1:
        m1, m2 = n, m1
    elif n >= m2:
        m2 = n

print(m2)
```

-----

#### Dal코칤 칰lohy

Dal코칤 칰koly: 	

- Spo캜칤tejte, kolik m치 zadan칠 캜칤slo cifer. 	
- Najd캩te 캜칤slo zapsan칠 sam칳mi jedni캜kami (v des칤tkov칠 soustav캩), kter칠 je d캩liteln칠 zadan칳m K. Jak se v캜as zastavit, kdy neexistuje? 	
- Najd캩te 캜칤slo mezi 1 a N s co nejv칤ce d캩liteli.	
- Vypo캜t캩te Eulerovu funkci (*Euler's totient function*) $\phi(n)$, kter치 je rovna po캜tu s $n$ nesoud캩ln칳ch (*relatively coprime*) 캜칤sel men코칤ch ne $n$.