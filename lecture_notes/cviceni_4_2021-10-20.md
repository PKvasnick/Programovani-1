

## `Programování` 1 pro matematiky

# 4. cvičení, 20,21-10-2021

###### tags: `Programovani 1 2021`, `středa`, `čtvrtek`

-----

**Obsah**:

0. Farní oznamy
1. Opakování
2. Domácí úkoly
3. Programujeme: Třídění a binární vyhledávání



### Farní oznamy

1. **Materiály k přednáškám** najdete v GitHub repozitáři https://github.com/PKvasnick/Programovani-1. Najdete tam také kód ke cvičením.

2. **Domácí úkoly** Dostali jste zatím 6 úkolú k prvním dvěma cvičením. 

   2 příklady jsou označené jako *bonusové* (Euklidova funkce a Pytagorejské trojice).  **Počítání bodů**: Očekává se, že dosáhnete 70% bodového zisku za povinné příklady, a to *libovolnou kombinací bodů za povinné a bonusové příklady*. 

3. **ReCodEx** Navzdory jistým omezením to je obrovská pomoc při správě domácích úkolů. Zatím se snažím průběžně kontrolovat každé odevzdané řešení, ale může se stát, že přestanu stíhat, když bude v oběhu víc příkladů najednou. 

4. **Někteří z vás ještě neodevzdali ani jeden příklad.** To nemusí být kritické, máte k dispozici dost času i bodů, ale nespoléhejte se, že to všechno doženete najednou. Úlohy mají *termíny*, protože po určité době ztrácejí opodstatnění. 

   *Máte s ReCodExem nějaké problémy?* *Funguje komunikace?* Vídíte mé komentáře k řešením? 

K domácím úkolúm a ReCodExu se ještě obširněji vrátím.



------

### Opakování

- [ ] Seznamy
```{python}
základní operace
```
- [ ] Co umí seznamy
  - append
  - del položka
  - insert
  - clear
  - index
- [ ] **Cyklus `while`:**
```{python}
while podmínka:
   příkazy
```
Příkazy pro kontrolu běhu cyklu:

`break` - v tomto místě opustit cyklus a pokračovat příkazem, následujícím za cyklem

`continue` - v tomto místě přejít na další iteraci cyklu (tedy na testování podmínky)

Větev `else`:

```{python}
while podmínka:
   příkazy
else
   příkazy-jen-jestli-proběhl-celý-cyklus
```


- [ ] **Vícenásobná přiřazení: **

  `a, b = b, a%b` (Krok modulícího Eulerova algoritmu)

   `a,b = a+b,a` (Čeho je toto krok?)

------
### Domácí úkoly

#### ReCodEx

Mnozí z vás svedli bitvu s ReCodExem, než se vám povedlo odevzdat své řešení. Je to dané několika specifiky:

ReCodEx používá pro testování vašeho kódu testy, které pozústávají 

1. ze souboru, ze kterého váš kód čte standardní vstup
2. ze souboru, se kterým ReCodEx porovnává standardní výstup vašeho kódu. 

Porovnání výstupu vašeho programu s očekávaným výstupem je strojové a poměrně jednoduché. **Cokoli, co váš program vypíše kromě očekávaného výstupu, povede k selhání v testu.** Příkladem, který znáte všichni, kdo už něco na ReCodEx posílali, jsou příkazy `input()` - nikdy v nich prosím nepoužívejte výzvu! `input("Zadej číslo: ")` způsobí, že váš program neprojde testy, protože výzva se vypíše do standardního výstupu. 

Z podobného důvodu vyžadují zadání nějaký **jednoduchý výstup**. Úloha o Pythagorejských trojicích například vyžaduje jen počet trojic a ne jejich vypsání, protože kontrola seznamu trojic není spolehlivá. 

#### Čistota a čitelnost kódu

Porovnejte prosím tyto dva kódy. Oba jsou správné a dělají správně to, co mají.  

Tento kód, včetně názvú identifikátorů, vyvinulo několik z vás:

```python
n = int(input())
m = int(input())
if n > m:
    print("P")
elif n < m:
    print("O")
else:
    print("R")
```

Porovnejte ho prosím s tímto kódem (to je také řešení, pocházející od jednoho z vás):

```python
cislo_princezny = int(input())
cislo_obra = int(input())

if cislo_princezny > cislo_obra:
    print("P")
elif cislo_princezny < cislo_obra:
    print("O")
else:
    print("R")
```

Problém s prvním kódem je, že si někde musíte zapamatovat přiřazení n→číslo od princezny, m→číslo od obra. Pak prvnímu kódu rozumíte stejně dobře jako druhému, ale v hlavě musíte držet náhodnou informaci, potřebnou k pochopení kódu. 

Kód, který má krátké názvy proměnných, není v nijakém smyslu výkonnější nebo úspornější než kód s dlouhými proměnnými. Na druhou stranu, kód s příliš dlouhými identifikátory se může hůř číst. 

**Jména objektů v Pythonu:** Počáteční písmeno, pak kombinace velkých i malých písmen, číslic a podtržítek. 

**Snažte se prosím používat názvy proměnných, které reflektují jejich význam. **

#### Prostředky Pythonu

Hodně z vás zná z Pythonu víc, než jsme zatím probrali. Přijímám i řešení, která používají prosťredky jazyka, které jsme zatím neprobírali, 

- pokud to není v rozporu s účelem zadání - tedy když máte sami naprogramovat něco, na co existuje v Pythonu knihovní funkce - například jsme programovali GCD(a,b), zatímco máme funkci math.gcd(), která to udělá za vás.
- pokud to vede k čistšímu a efektivnímu kódu - mezi řešeními domácích úkolů se našly i takové, které využívali funkce, seznamy, množiny atd a to všechno spletené do ošklivého špatně čitelného kódu. 

Cílem tohoto cvičení je naučit vás psát nejen správný, ale i čistý a dobře čitelný kód. Toho dosáhnete i účelným využíváním rozmanitých prostředků jazyka.  



### Seznamy

```python
>>> cisla = [1,2,3,4,5]
>>> type(cisla)
list
>>> cisla[0] # V Pythonu číslujeme od 0
1
>>> cisla[4] # takže poslední prvek je počet prvků - 1
5
>>> len(cisla) # počet prvků je len
5
>>> cisla[-1] # Indexování je velmi flexibilní
5
>>> cisla[1:3]
[2, 3]
>>> cisla[0:5]
[1, 2, 3, 4, 5]
>>> cisla[:3]
[1, 2, 3]
>>> cisla[3:]
[4, 5]
>>> cisla.append(6) # Přidání nového prvku do seznamu
>>> cisla
[1, 2, 3, 4, 5, 6]
```

Seznamy můžou obsahovat různé věci:

```python
zaci = ["Honza", "Jakub", "Franta"]
matice = [[1,2,3],[2,3,1]] # Neužitečná implementace matice
matice[0]
>>> [1,2,3]
matice[1][1] 
>>> 3
>>> [1,2] + [3,4] # aritmetika pro seznamy
[1, 2, 3, 4]
>>> [1,2]*3
[1, 2, 1, 2, 1, 2]
```

 ... ale také položky různého druhu:

```python
>>> lst = [1,"Peter",True]
>>> lst
[1, 'Peter', True]
>>> del lst[0]
>>> lst
['Peter', True]
>>> 
```

Pozor na kopírování seznamů:

```python
>>> a = ['jeden', 'dva', 'tri']
>>> b = a
>>> a[0] = 'jedna'
>>> b
['jedna', 'dva', 'tri']
>>> c = [[1,2]]*3
>>> c
[[1, 2], [1, 2], [1, 2]]
>>> c[0][0] = 0
>>> c
[[0, 2], [0, 2], [0, 2]]
```

Seznam umíme lehce setřídit nebo obrátit:

```python
>>> c = [2,4,1,3]
>>> sorted(c)
[1,2,3,4]
>>> reversed[c]
[3,1,4,2]
```

O třídění budeme mluvit na následujícím cvičení. 

#### Cyklus `for` 

```python
In [9]: cisla = [1,1,2,3,5,8]

In [10]: for cislo in cisla:
    ...:     print(cislo, end = "-")
    ...:
1-1-2-3-5-8-
```

Často chceme, aby cyklus probíhal přes jednoduchou číselnou řadu, např. $1,2,\dots,n$. Na generování takovýchto řad slouží funkce `range`:

```python
>>> for i in range(5):
	print(i, end = ' ')
	
0 1 2 3 4 
```

`range` respektuje číslovací konvence Pythonu a podporuje ještě další argumenty: začátek sekvence a krok:

```python
>>> for i in range(2,10,3):
...     print(i)
...
2
5
8
```

Argumenty nemusí být kladná čísla, takže můžeme lehko iterovat pozpátku:

```python
>>> for i in range(9,-1,-1):
---    print(i, end = ' ') 
---
9 8 7 6 5 4 3 2 1 0 >>> 
```

Tedy chceme-li iterovat pozpátku přes `range(n)`, použijeme `range(n-1,-1, -1)`.Abychom se nespletli, nabízí Python elegantnější řešení:

```python
>>> for i in reversed(range(5)):
	print(i, end = " ")

4 3 2 1 0 
```

a tuto funkci můžeme použít na libovolný seznam:

```python
>>> cisla = ["jedna", "dvě", "tři", "čtyři"]
>>> for cislo in reversed(cisla):
	print(cislo, end = " ")

čtyři tři dvě jedna 
```

`range(n)` není seznam, i když podporuje přístup k polžkám přes index:

```python
>>> range(10)
range(0, 10)
>>> type(range(10))
<class 'range'>
>>> range(10)[-1]
9
>>> list(range(10))
[0,1,2,3,4,5,6,7,8,9]
>>> [i for i in range(10)]
[0,1,2,3,4,5,6,7,8,9]
```

Také `reversed/seznam)`není seznam, ale reverzní iterátor:

```python
>>> reversed(cisla)
<list_reverseiterator object at 0x000002AE55D45370>
>>> [s for s in reversed(cisla)]
['čtyři', 'tři', 'dvě', 'jedna']
```

ale `sorted(seznam)` je seznam:

```python
>>> sorted(c)
[1, 2, 3, 4]
```

#### Fibonacciho čísla

$$
Fib(0) = 1,\quad
Fib(1) = 1,\quad
Fib(n) = Fib(n-1) + Fib(n-2),\quad = 2, 3, \dots
$$



*Úloha*: Vypište prvních n Fibonacciho čísel. 

Úvahy: 

- potřebujeme vůbec seznam?

```python
# Vypsat prvnich n Fibonacciho cisel
n = int(input())
a = 1
print(a, end = ", ")
b = 1
print(b, end = ", ")
for k in range(3,n+1):
    b, a = b+a, b
    print(b, end = ", ")
```

- Můžeme začít seznamem prvních dvou čísel, a pak dopočítávat a přidávat na konec další čísla:

  ```python
  # Vypsat prvnich n Fibonacciho cisel
  n = int(input())
  fibs = [1,1]
  while len(fibs)<n:
  	fibs.append(fibs[-1] + fibs[-2])
  print(fibs)
  ```

- Nikdy nechcete alokovat paměť po malých kouscích. Když předem víme délku seznamu, je nejlepší zřídit ho celý a jenom ho naplnit. 

#### Příklad: Erastothénovo síto

*Úloha*: Najděte všechna prvočísla menší nebo rovná n.

Úvahy:

- Musíme si nějak pamatovat, která čísla jsme už vyšktrtli a která nám ještě zůstala. 
- Jedno řešení je, že vezmeme seznam všech čísel od 2 do n a budeme odstraňovat ty, které nejsou prvočísly. To je ale pomalé a v proměnlivém poli se špatně iteruje - není snadné určit, kde právě v poli jsme. 
- Lepší je vzít seznam logických hodnot. Index bude číslo, a hodnota bude označovat, jestli jej zatím považujeme za prvočíslo anebo už ne. 

```python
# vypiš všechna prvočísla menší nebo rovná n

n = int(input())

prvocisla = [True]*(n+1) # včetně nuly a n
prvocisla[0] = False
prvocisla[1] = False
for i in range(2,n+1):
    if prvocisla[i]:
        for j in range(i*i, n+1, i):
            prvocisla[j]=False

print("Pocet: ", sum(prvocisla))
for i in range(n+1):
    if prvocisla[i]:
        print(i, end = ', ')
```

<!--- středa --->

-----

#### Další úkoly

 Je dána posloupnost čísel... 	

- zjistěte, jestli jsou všechna navzájem různá. 	
- najděte dvojici s co nejmenším rozdílem. 	
- vypište všechna opakující se čísla (ale každé jen jednou). 	
- Umíte předchozí úkoly vyřešit efektivněji, pokud víte, že všechna zadaná čísla leží od 1 do 100? 	

##### Pomůcka

Odkud vezmeme posloupnost?

```python
from random import randint

low = 0
high = 10
n = 10

print([randint(low, high) for i in range(10)])
```

