## ProgramovÃ¡nÃ­ 1 pro matematiky


# 2. cviÄenÃ­, 11-10-2023

**Obsah**:

0. FarnÃ­ oznamy
1. OpakovÃ¡nÃ­: datovÃ© typy v Pythonu
2. PÅ™Ã­kaz `if` 
3. PÅ™Ã­kaz `while`
4. Programujeme...

------



### FarnÃ­ oznamy

1. **MateriÃ¡ly k pÅ™ednÃ¡Å¡kÃ¡m** najdete v GitHub repozitÃ¡Å™i https://github.com/PKvasnick/Programovani-1. Najdete tam takÃ© kÃ³d ke cviÄenÃ­m.
   - Soubory si mÅ¯Å¾ete ÄÃ­st pÅ™Ã­mo na GitHubu. Pokud si chcete stÃ¡hnout nebo zkopÃ­rovat kÃ³d, pÅ™epnÄ›te do _Raw_ zobrazenÃ­ (aby se vÃ¡m nezkopÃ­rovaly ÄÃ­sla Å™Ã¡dkÅ¯ a pod.), Ctrl-A + Ctrl-C.
   - Windows: Nainstalujte si aplikaci GitHub Desktop a naklonujte si celÃ½ repozitÃ¡Å™ do svÃ©ho poÄÃ­taÄe: ZelenÃ© tlaÄÃ­tko `Code`, z nabÃ­dky `Open with GitHub Desktop`. 
   - Pokud se v nÄ›jakÃ©m okamÅ¾iku neobejdete bez zÅ™Ã­zenÃ­ konta na GitHubu, zÅ™iÄte si jej. 

2. **DomÃ¡cÃ­ Ãºkoly** AÅ¾ dnes dostanete prvnÃ­ domÃ¡cÃ­ Ãºkol. 


3. **KaÅ¾dÃ©mu vÅ¡e chodÃ­?** - Python? ReCodEx?

-----

### OpakovÃ¡nÃ­ + nÄ›co novÃ© k tomu

```python
a = 3.1
b = 4.5
a+b
type(a)
type(b)
c = int(a)
c
type(c)

```

```python
s = 'Hello, world'
s
s[2]
s[2:5]
```

â€‹	MÅ¯Å¾eme pouÅ¾Ã­vat jednoduchÃ© i dvojitÃ© uvozovky, i kdyÅ¾ jednoduchÃ© jsou pro Python typiÄtÄ›jÅ¡Ã­. IndexovÃ¡nÃ­ je stejnÃ© jako u seznamÅ¯. Å˜etÄ›zce mÅ¯Å¾eme takÃ© seÄÃ­tat:

```python
s1='Hello'
s2 = 'world'
s1 + ' ' + s2
```

Seznamy, mnoÅ¾iny a slovnÃ­ky

```python
>>> seznam = [1, 2, 3]
>>> seznam[0]
1
>>> seznam[1]
2
>>> seznam.append(4)
>>> seznam
[1, 2, 3, 4]
>>> seznam.pop()
4
>>> seznam
[1, 2, 3]
```

```python
>>> ovoce = {"jablka", "hruÅ¡ky", "pomeranÄe"}
>>> ovoce.add("Å¡vestky")
>>> ovoce
{"jablka", "hruÅ¡ky", "Å¡vestky", "pomeranÄe"}
>>> ovoce.add("hruÅ¡ky")
>>> ovoce
{"jablka", "hruÅ¡ky", "Å¡vestky", "pomeranÄe"}
```

```python
>>> ÄÃ­slice = {"jedna" : 1, "dva" : 2, "tÅ™i" : 3}
>>> ÄÃ­slice["tÅ™i"]
3
>>> ÄÃ­slice["ÄtyÅ™i"] = 4
>>> ÄÃ­slice
{"jedna" : 1, "dva" : 2, "tÅ™i" : 3, "ÄtyÅ™i" : 4}
```

### Vstup z konzole

`print` nÃ¡m tiskne vÄ›ci z programu, ale jak dostat do programu nÄ›jakÃ½ vstup?

```python
a = input()
b = input()
print(a, b, a>b)

=============== RESTART: C:\Users\kvasn\Dropbox\Python_MFF\sk.py ===============
2
13
2 13 True
```

```python
a = int(input())
b = int(input())
print(a, b, a>b)

=============== RESTART: C:\Users\kvasn\Dropbox\Python_MFF\sk.py ===============
2
13
2 13 False
```

**input() a ReCodEx**

1. Funkce `input()` funguje v ReCodExu ponÃ©kud jinak neÅ¾ na vaÅ¡i konzole. ReCodEx pÅ™i hodnocenÃ­ vaÅ¡ich Ãºloh pÅ™esmÄ›ruje soubor se vstupnÃ­mi Ãºdaji pro bÄ›h programu na standardnÃ­ vstup programu. ZatÃ­mco pÅ™i pouÅ¾itÃ­ `input()` na konzoli je vÃ½stupem znakovÃ½ Å™etÄ›zec, kterÃ½ jste zadali, bez koncovÃ©ho znaku novÃ©ho Å™Ã¡dku (\n), v ReCodExu bude vstup obsahovat i koncovÃ© \n. 
2. Pro Ãºlohy odevzdÃ¡vanÃ© v ReCodExu nikdy nepouÅ¾Ã­vejte vÃ½zvu ve funkci `input()`. Tedy vÅ¾dy volejte funkci bez parametrÅ¯, `input()` a ne `input("Zadej cislo: ")` nebo nÄ›co podobnÃ©ho.



NejspÃ­Å¡ vÃ¡s nepÅ™ekvapÃ­, Å¾e takÃ© existuje `float()`, `str()` a `bool()`


```{python}
In [3]: int(4.9)
Out[3]: 4

In[4]: int("Petr")
Traceback (most recent call last):
  File "<pyshell#72>", line 1, in <module>
    int("Petr")
ValueError: invalid literal for int() with base 10: 'Petr'

In [5]: round(4.9,0)
Out[5]: 5.0

In [6]: float(5)
Out[6]: 5.0

In [7]: bool(0.5)
Out[7]: True

In [8]: bool(-1.0)
Out[8]: True

In [9]: bool(0.0)
Out[9]: False

In [10]: str(4.6)
Out[10]: '4.6'

In [11]: str(True)
Out[11]: 'True'

In [12]: str(False)
Out[12]: 'False'


```

- [ ] OperÃ¡tory `+,-,*,/,**,//,%, ==, and, or, not`

- [ ] PÅ™iÅ™azenÃ­ `=` a pÅ™iÅ™azenÃ­ s operacÃ­ `Â°+=, -=, *=, /=`, ale takÃ© tÅ™eba `%=` - operÃ¡tor _vymodulenÃ­_, s kterÃ½m se dnes setkÃ¡me.

- [ ] MatematickÃ© funkce z balÃ­ku _math_,  `import math` a pak `math.*`, napÅ™. `math.sin()`.

- [ ] Funkce pro ÄtenÃ­ Å™etÄ›zce ze standardnÃ­ho vstupu `input(vÃ½zva)` a funkce pro tisk do standardnÃ­ho vÃ½stupu `print(objekt1, objekt2, ...)`


### Print podrobnÄ›ji

```python
print(1,2,3); print(4,5,6)
1 2 3
4 5 6
```

Konverze do Å™etÄ›zcovÃ© reprezentace, poloÅ¾ky oddÄ›lenÃ© mezerami, na konci znak novÃ©ho Å™Ã¡dku.

```python
print(1, 2, 3, sep = "-", end = "!!!\n")
```

FormÃ¡tovÃ¡nÃ­ vÃ½stupu:

```python
jmeno = "Petr"
vaha = 100
print(jmeno, "vÃ¡Å¾Ã­", vaha, "kilogramÅ¯")
print(f"{jmeno} vÃ¡Å¾Ã­ {vaha} kilogramÅ¯")
```

### PÅ™Ã­kazy `if` a `while`

- [ ] PodmÃ­nÄ›nÃ½ pÅ™Ã­kaz 

  ```{python}
  if podmÃ­nka:
     pÅ™Ã­kazy
  ```

- [ ] PÅ™Ã­kaz cyklu

  ```{python}
  while podmÃ­nka:
     pÅ™Ã­kazy
  ```

  kde _pÅ™Ã­kazy_ mÅ¯Å¾ou bÃ½t pÅ™Ã­kazy pÅ™iÅ™azenÃ­, volÃ¡nÃ­ funkce, dalÅ¡Ã­ podmÃ­nÄ›nÃ© pÅ™Ã­kazy nebo pÅ™Ã­kazy cyklu, a dnes se nauÄÃ­me, Å¾e takÃ© pÅ™Ã­kazy `pass` (nedÄ›lej nic), `break` (opuÅ¡tÄ›nÃ­ cyklu) a `continue` (pÅ™echod na dalÅ¡Ã­ iteraci cyklu).

-----

#### PÅ™Ã­kaz `if`

ÃšplnÄ›jÅ¡Ã­ syntaxe pÅ™Ã­kazu `if`:

```{python}
if podmÃ­nka:
   pÅ™Ã­kazy
else:			# volitelnÄ›
   pÅ™Ã­kazy
```

VÄ›tev `else` je nepovinnÃ¡; kdyÅ¾ chceme vynechat pÅ™Ã­kazy ve vÄ›tvi `if`, musÃ­me pouÅ¾Ã­t prÃ¡zdnÃ½ pÅ™Ã­kaz `pass`. 

VÄ›tve `elif`: V pÅ™Ã­padÄ› Å™etÄ›zÃ­cÃ­ch pÅ™Ã­kazÅ¯ `if` mÅ¯Å¾eme namÃ­sto konstrukce

```{python}
if podmÃ­nka1:
   pÅ™Ã­kazy
else:
   if podmÃ­nka2:
      pÅ™Ã­kazy
   else:
      pÅ™Ã­kazy
         
```

psÃ¡t

```{python}
if podmÃ­nka1:
   pÅ™Ã­kazy
elif podmÃ­nka2:
   pÅ™Ã­kazy
else:
   pÅ™Ã­kazy
```

coÅ¾ je o nÄ›co pÅ™ehlednÄ›jÅ¡Ã­ - hlavnÄ› dÃ­ky plochÃ©mu (nerostoucÃ­mu) odsazenÃ­.

-----

#### PÅ™Ã­kaz `while`

```{python}
while podmÃ­nka:
   pÅ™Ã­kazy
```

PÅ™Ã­kazy pro kontrolu bÄ›hu cyklu:

`break` - v tomto mÃ­stÄ› opustit cyklus a pokraÄovat pÅ™Ã­kazem, nÃ¡sledujÃ­cÃ­m za cyklem

`continue` - v tomto mÃ­stÄ› pÅ™ejÃ­t na dalÅ¡Ã­ iteraci cyklu (tedy na testovÃ¡nÃ­ podmÃ­nky)

NekoneÄnÃ½ cyklus: podmÃ­nka stÃ¡le platÃ­, a o ukonÄenÃ­ cyklu rozhodneme v tÄ›le za pouÅ¾itÃ­ pÅ™Ã­kazu `break`:

```{python}
while True:
   pÅ™Ã­kazy
   if podmÃ­nka:
      break
```

PÅ™Ã­kaz `while` mÃ¡ takÃ© volitelnou vÃ©tev `else`. PÅ™Ã­kazy v tÃ©to vÄ›tvi se vykonajÃ­, pokud cyklus Å™Ã¡dnÄ› skonÄÃ­ (tedy ne v pÅ™Ã­padÄ› opuÅ¡tÄ›nÃ­ cyklu pÅ™Ã­kazem `break`).

```{python}
while podmÃ­nka:
   pÅ™Ã­kazy1
else:
   pÅ™Ã­kazy2
```

-----

### PÅ™Ã­klady

#### Test prvoÄÃ­sel

Chceme otestovat, zda je ÄÃ­slo $n$ ze vstupu prvoÄÃ­slo.

Metoda: U vÅ¡ech ÄÃ­sel $d<n$ provÄ›Å™Ã­m, zda jsou dÄ›liteli $n$.

```{python}
#!/usr/bin/env python3

# Otestuje, zda ÄÃ­slo je prvoÄÃ­slem

n = int(input())
d = 2
mam_delitele = False

while d < n:
    if n%d == 0:
        print("ÄŒÃ­slo", n, "je dÄ›litelnÃ©", d)
        mam_delitele = True
        break
    d += 1

if not mam_delitele:
    print("ÄŒÃ­slo", n, "je prvoÄÃ­slo")
```

To nenÃ­ nijak zvlÃ¡Å¡Å¥ efektivnÃ­ metoda, ale to nÃ¡m nevadÃ­, my jsme celÃ­ rÃ¡di, Å¾e umÃ­me napsat nÄ›co, co v zÃ¡sadÄ› funguje. 

PojÄme opatrnÄ› vylepÅ¡ovat. ZÃ¡sadnÃ­ vylepÅ¡enÃ­ kÃ³du by bylo, kdybychom "nahÃ½" cyklus `while` umÄ›li celÃ½ zapouzdÅ™it do jedinÃ©ho pÅ™Ã­kazu. 

ğŸ˜ _PokroÄilÃ© kolegy poprosÃ­m o tvar onoho jedinÃ©ho pÅ™Ã­kazu._

Asi prvnÃ­ vÄ›c, kterÃ¡ nÃ¡m vadÃ­, je stavovÃ¡ promÄ›nnÃ¡ `mam_delitele`. A tÃ© se v prvnÃ­m kroku zbavÃ­me za pouÅ¾itÃ­ vÄ›tve `else`:

```{python}
#!/usr/bin/env python3

# Otestuje, zda ÄÃ­slo je prvoÄÃ­slem (2. pokus)

n = int(input())
d = 2

while d < n:
    if n%d == 0:
        print("ÄŒÃ­slo", n, "je dÄ›litelnÃ©", d)
        break
    d += 1
else:
    print("ÄŒÃ­slo", n, "je prvoÄÃ­slo")
```

Jak bychom mohli dÃ¡l vylepÅ¡it nÃ¡Å¡ test?

PopÅ™emÃ½Å¡lÃ­me, a zatÃ­m vymyslÃ­me, jak bychom vypsali vÅ¡echna provÄÃ­sla menÅ¡Ã­ nebo rovnÃ¡ $n$. NejjednoduÅ¡Å¡Ã­ metoda bude projÃ­t vÅ¡echna ÄÃ­sla od 2 do $n$, u kaÅ¾dÃ©ho rozhodnout, zda je prvoÄÃ­slem, a jestli ano, vypsat ho. 

```python
#!/usr/bin/env python3
# VypÃ­Å¡e vÅ¡echna prvoÄÃ­sla od 1 do n

n = int(input())

x = 2
while x <= n:
    d = 2
    while d < x:
        if x%d == 0:
            break
        d += 1
    else:
        print(x)

    x += 1

```

Optimalizace je v tomto pÅ™Ã­padÄ› jeÅ¡tÄ› vÃ­ce nasnadÄ›, jenomÅ¾e si zatÃ­m neumÃ­me pamatovat vÄ›ci - napÅ™Ã­klad vÅ¡echny prvoÄÃ­sla, kterÃ© jsme dosud nalezli.

ğŸ˜ _PokroÄilÃ© kolegy_ poprosÃ­m o optimalizovanÃ½ algoritmus, napÅ™. Erastothenovo sÃ­to. 

-----

#### SouÄet posloupnosti ÄÃ­sel

```python
#!/usr/bin/env python3

# NaÄteme ze vstupu posloupnost ÄÃ­sel, ukonÄenou -1.
# VypÃ­Å¡eme jejich souÄet. 

s = 0
while True:
    n = int(input())
    if n == -1:
        break
    s += n
print(s)
```

ProÄ nemÅ¯Å¾eme na konci jenom stisknout Enter a nezadat nic?

ğŸ˜ _PokroÄilÃ© kolegy poprosÃ­m_

- o variantu se stiskem Enter 
- a pro vypsÃ¡nÃ­ aritmetickÃ©ho prÅ¯mÄ›ru a standardnÃ­ odchylky._

**DomÃ¡cÃ­ Ãºkol na pÅ™Ã­Å¡tÃ­ tÃ½den:**

* Obr a princezna
* SpoÄÃ­st a vypsat poÄet cifer zadanÃ©ho celÃ©ho ÄÃ­sla
* Vypsat zadanÃ© ÄÃ­slo jako souÄin prvoÄinitelÅ¯ 
