## Programov치n칤 1 pro matematiky

# 2. cvi캜en칤, 6,7-10-2021

###### tags: `Programovani 1 2021`, `st콏eda`, `캜tvrtek`

-----

**Obsah**:

0. Farsk칠 oznamy
1. Opakov치n칤
2. P콏칤kaz `if` 
3. P콏칤kaz `while`
4. Programujeme...

------



### Farn칤 oznamy

1. **Materi치ly k p콏edn치코k치m** najdete v GitHub repozit치콏i https://github.com/PKvasnick/Programovani-1. Najdete tam tak칠 k칩d k cvi캜en칤m a k dom치c칤m 칰kol콢m.
   - Soubory si m콢쬰te 캜칤st p콏칤mo na GitHubu. Pokud si chcete st치hnout nebo zkop칤rovat k칩d, p콏epn캩te do _Raw_ zobrazen칤 (aby se v치m nezkop칤rovaly 캜칤sla 콏치dk콢 a pod.), Ctrl-A + Ctrl-C.
   - Windows: Nainstalujte si aplikaci GitHub Desktop a naklonujte si cel칳 repozit치콏 do sv칠ho po캜칤ta캜e: Zelen칠 tla캜칤tko `Code`, z nab칤dky `Open with GitHub Desktop`. 
   - Pokud se v n캩jak칠m okam쬴ku neobejdete bez z콏칤zen칤 konta na GitHubu, z콏i캞te si jej. 
2. **Dom치c칤 칰koly** Tady se omlouv치m, pral jsem se s ReCodExem, abych v치m mohl zadat smyslupln칠 dom치c칤 칰koly, ale nepovedlo se. Kdy budete ps치t v칤c k칩du, budou snad omezen칤 ReCodExu m칠n캩 obt캩쬿j칤c칤. 
3. **Personel inventory** - chyb칤
4. **Cvi캜en칤 pro pokro캜il칠 ** - pros칤m je코t캩 vydr쬾e, oslov칤m v치s v pr콢b캩hu t칳dne. Zat칤m dostanete p치r 칰kol콢 v pr콢b캩hu p콏edn치코ky. 

-----

### Opakov치n칤

- [ ] Z치kladn칤 instalace Pythonu
- [ ] 캛칤sla a 콏et캩zce, aritmetick칠 a logick칠 operace
- [ ] Konverze `int()` , (a nejsp칤코 v치s nep콏ekvap칤, 쬰 tak칠 existuje `float()`, `str()` a `bool()`.

```{python}
In [4]: int(4.9)
Out[4]: 4

In [5]: round(4.9,0)
Out[5]: 5.0

In [6]: float(5)
Out[6]: 5.0

In [7]: bool(0.5)
Out[7]: True

In [8]: bool(-1.0)
Out[8]: True

In [9]: bool(0.0)
Out[9]: False

In [10]: str(4.6)
Out[10]: '4.6'

In [11]: str(True)
Out[11]: 'True'

In [12]: str(True)
Out[12]: 'True'

In [13]: str(False)
Out[13]: 'False'
```

- [ ] Oper치tory `+,-,*,/,**,//,%, ==, and, or, not`

- [ ] P콏i콏azen칤 `=` a p콏i콏azen칤 s operac칤 `춿+=, -=, *=, /=`, ale tak칠 t콏eba `%=` - oper치tor _vymodulen칤_, s kter칳m se dnes setk치me.

- [ ] Matematick칠 funkce z bal칤ku _math_,  `math.*`, nap콏. `math.sin()`.

- [ ] Funkce pro 캜ten칤 콏et캩zce ze standardn칤ho vstupu `input(v칳zva)` a funkce pro tisk do standardn칤ho v칳stupu `print(objekt1, objekt2, ...)`

- [ ] Podm칤n캩n칳 p콏칤kaz 

  ```{python}
  if podm칤nka:
     p콏칤kazy
  ```

- [ ] P콏칤kaz cyklu

  ```{python}
  while podm칤nka:
     p콏칤kazy
  ```

  kde _p콏칤kazy_ m콢쬺u b칳t p콏칤kazy p콏i콏azen칤, vol치n칤 funkce, dal코칤 podm칤n캩n칠 p콏칤kazy nebo p콏칤kazy cyklu, a dnes se nau캜칤me, 쬰 tak칠 p콏칤kazy `pass` (ned캩lej nic), `break` (opu코t캩n칤 cyklu) a `continue` (p콏echod na dal코칤 iteraci cyklu).

-----

### P콏칤kaz `if`

칔pln치 syntaxe p콏칤kazu `if`:

```{python}
if podm칤nka:
   p콏칤kazy
else:			# voliteln캩
   p콏칤kazy
```

V캩tev `else` je nepovinn치; kdy chceme vynechat p콏칤kazy ve v캩tvi `if`, mus칤me pou쮂셦 pr치zdn칳 p콏칤kaz `pass`. 
V캩tve `elif`: V p콏칤pad캩 콏et캩z칤c칤ch p콏칤kaz콢 `if` m콢쬰me nam칤sto konstrukce

```{python}
if podm칤nka1:
   p콏칤kazy
else:
   if podm칤nka2:
      p콏칤kazy
   else:
      p콏칤kazy
         
```

ps치t

```{python}
if podm칤nka1:
   p콏칤kazy
elif podm칤nka2:
   p콏칤kazy
else:
   p콏칤kazy
```

co je o n캩co p콏ehledn캩j코칤 - m칤n slov a hlavn캩 ploch칠 odsazen칤.

-----

### P콏칤kaz `while`

```{python}
while podm칤nka:
   p콏칤kazy
```

P콏칤kazy pro kontrolu b캩hu cyklu:

`break` - v tomto m칤st캩 opustit cyklus a pokra캜ovat p콏칤kazem, n치sleduj칤c칤m za cyklem

`continue` - v tomto m칤st캩 p콏ej칤t na dal코칤 iteraci cyklu (tedy na testov치n칤 podm칤nky)

Nekone캜n칳 cyklus: podm칤nka st치le plat칤, a o ukon캜en칤 cyklu rozhodneme v t캩le za pou쬴t칤 p콏칤kazu `break`:

```{python}
while True:
   p콏칤kazy
   if podm칤nka:
      break
```

P콏칤kaz `while` m치 tak칠 volitelnou v칠tev `else`. P콏칤kazy v t칠to v캩tvi se vykonaj칤, pokud cyklus 콏치dn캩 skon캜칤 (tedy ne v p콏칤pad캩 opu코t캩n칤 cyklu p콏칤kazem `break`).

```{python}
while podm칤nka:
   p콏칤kazy1
else:
   p콏칤kazy2
```

-----

### P콏칤klady

#### Test prvo캜칤sel

Chceme otestovat, zda je 캜칤slo $n$ ze vstupu prvo캜칤slo.

Metoda: U v코ech 캜칤sel $d<n$ prov캩콏칤m, zda jsou d캩liteli $n$.

```{python}
#!/usr/bin/env python3

# Otestuje, zda 캜칤slo je prvo캜칤slem

n = int(input())
d = 2
mam_delitele = False

while d < n:
    if n%d == 0:
        print("캛칤slo", n, "je d캩liteln칠", d)
        mam_delitele = True
        break
    d += 1

if not mam_delitele:
    print("캛칤slo", n, "je prvo캜칤slo")
```

To nen칤 nijak zvl치코콘 efektivn칤 metoda, ale to n치m nevad칤, my jsme cel칤 r치di, 쬰 um칤me napsat n캩co, co v z치sad캩 funguje. 

Poj캞me opatrn캩 vylep코ovat. Z치sadn칤 vylep코en칤 k칩du by bylo, kdybychom "nah칳" cyklus `while` um캩li cel칳 zapouzd콏it do jedin칠ho p콏칤kazu. 

游땙 _Pokro캜il칠 kolegy popros칤m o tvar onoho jedin칠ho p콏칤kazu._

Asi prvn칤 v캩c, kter치 n치m vad칤, je stavov치 prom캩nn치 `mam_delitele`. A t칠 se v prvn칤m kroku zbav칤me za pou쬴t칤 v캩tve `else`:

```{python}
#!/usr/bin/env python3

# Otestuje, zda 캜칤slo je prvo캜칤slem (2. pokus)

n = int(input())
d = 2

while d < n:
    if n%d == 0:
        print("캛칤slo", n, "je d캩liteln칠", d)
        break
    d += 1
else:
    print("캛칤slo", n, "je prvo캜칤slo")
```

Jak bychom mohli d치l vylep코it n치코 test?

Pop콏em칳코l칤me, a zat칤m vymysl칤me, jak bychom vypsali v코echna prov캜칤sla men코칤 nebo rovn치 $n$. Nejjednodu코코칤 metoda bude proj칤t v코echna 캜칤sla od 2 do $n$, u ka쬯칠ho rozhodnout, zda je prvo캜칤slem, a jestli ano, vypsat ho. 

```python
#!/usr/bin/env python3
# Vyp칤코e v코echna prvo캜칤sla od 1 do n

n = int(input())

x = 2
while x <= n:
    d = 2
    while d < x:
        if x%d == 0:
            break
        d += 1
    else:
        print(x)

    x += 1

```

Optimalizace je v tomto p콏칤pad캩 je코t캩 v칤ce nasnad캩, jenom쬰 si zat칤m neum칤me pamatovat v캩ci - nap콏칤klad v코echny prvo캜칤sla, kter칠 jsme dosud nalezli.

游땙 _Pokro캜il칠 kolegy_ popros칤m o algoritmus s memoizac칤 a/anebo Erastothenovo s칤to. 

-----



### Euklid콢v algoritmus

Z치kladn칤 verze s ode캜칤t치n칤m: $x>y: \gcd(x,y) = \gcd(x-y,y)$

```python
#!/usr/bin/env python3
# Nejv캩t코칤 spole캜n칳 d캩litel: Euklid콢v algoritmus s od캜칤t치n칤m

x = int(input())
y = int(input())

while x != y:
    if x > y:
        x -= y
    else:
        y -= x

print(x)

```

Pokud je jedno z 캜칤sel o hodn캩 men코칤 ne druh칠, mo쬹치 budeme opakovan캩 ode캜칤tat, a to n치s spomaluje (n치ro캜nost algoritmu je line치rn칤 v n). Je proto lep코칤 v jednom kroku ode캜칤tat kolikr치t to jde: _ode캜칤t치n칤 nahrad칤me operac칤 modulo_:

```python
#!/usr/bin/env python3
# Nejv캩t코칤 spole캜n칳 d캩litel: Euklid콢v algoritmus s modulem

x = int(input())
y = int(input())

while x > 0 and y > 0:
    if x > y:
        x %= y
    else:
        y %= x

if x > 0:
    print(x)
else:
    print(y)
```

Proto쬰 `x % y < y`, po ka쬯칠 operaci modulo v칤me, jak치 je vz치jemn치 velikost x a y. K칩d tedy m콢쬰me v칳razn캩 zdokonalit:

```python
#!/usr/bin/env python3
# Nejv캩t코칤 spole캜n칳 d캩litel: Euklid콢v algoritmus s p치r triky nav칤c

x = int(input())
y = int(input())

while y > 0:
    x, y = y, x%y

print(x)
```

Tady si v코imneme p콏i콏azen칤 `x, y = y, x%y`. Je to dvoj칤 p콏i콏azen칤, ale nelze jej rozd캩lit na dv캩 p콏i콏azen칤 `x=y` a `y=x%y`, proto쬰 druh칠 p콏i콏azen칤 se po prvn칤m zm캩nilo na `y=y%y` a tedy y bude p콏i콏azena 0.  

1. M콢쬰me se pt치t, pro캜 to funguje (proto쬰 z dvojice na prav칠 stran캩 se p콏ed p콏i콏azen칤m vytvo콏칤 nem캩nn치 - konstantn칤 dvojice - _tuple_ - a ten se p콏i p콏i콏azen칤 "rozbal칤" do x a y). 
2. Jak byste takov칠to p콏i콏azen칤 rozepsali na jednoduch치 p콏i콏azen칤, aby to fungovalo?

Toto je u celkem v칳konn칳 algoritmus, po캜etn칤 n치ro캜nost je $\sim \log n$ Te캞 m콢쬰me d캩lat v칤c v캩c칤, nap콏칤klad spo캜칤st Eulerovu funkci pro prvn칤ch mili칩n 캜칤sel a podobn캩. 

-----

#### Sou캜et posloupnosti 캜칤sel

```python
#!/usr/bin/env python3

# Na캜teme ze vstupu posloupnost 캜칤sel, ukon캜enou -1.
# Vyp칤코eme jejich sou캜et. 

s = 0
while True:
    n = int(input())
    if n == -1:
        break
    s += n
print(s)
```

Pro캜 nem콢쬰me na konci jenom stisknout Enter a nezadat nic?

游땙 _Pokro캜il칠 kolegy popros칤m_

- o variantu se stiskem Enter 
- a pro vyps치n칤 aritmetick칠ho pr콢m캩ru a standardn칤 odchylky._

#### Druh칠 nejv캩t코칤 캜칤slo posloupnosti

Na캜t캩te ze vstupu posloupnost 캜칤sel ukon캜enou -1. Pak vypi코te 

- druh칠 nejv캩t코칤 캜칤slo posloupnosti
- jeho polohu v posloupnosti

Abychom pochopili, jak to ud캩lat, p콏em칳코l칤me v term칤nech stavu na코eho p치tr치n칤 po druh칠m nejv캩t코칤m 캜칤sle. Abychom spr치vn캩 nalo쬴li s nov칳m 캜칤slem, mus칤me si pamatovat aktu치ln캩 nejv캩t코칤 a druh칠 nejv캩t코칤 캜칤slo posloupnosti $m_1$ a $m_2$. Kdy n치m p콏ijde nov칳 캜len posloupnosti $m$, mus칤me tento stav - tedy 캜칤sla  $m_1$ a $m_2$ - aktualizovat podle toho, jak치 je jeho velikost. Pokud p콏ijde $m=-1$, vyp칤코eme $m_2$. 

```python
#!/usr/bin/env python3
# Na캜칤t치 캜칤sla ze vstupu ukon캜en치 -1,
# vyp칤코e druh칠 nejv캩t코칤 z nich

m1 = 0      # Zat칤m nejv캩t코칤 캜칤slo
m2 = 0      # Zat칤m druh칠 nejv캩t코칤

while True:
    n = int(input())
    if n == -1:
        break

    if n >= m1:
        m1, m2 = n, m1
    elif n >= m2:
        m2 = n

print(m2)
```

-----

#### Dal코칤 칰lohy

Dal코칤 칰koly: 	

- Spo캜칤tejte, kolik m치 zadan칠 캜칤slo cifer. 	
- Najd캩te 캜칤slo zapsan칠 sam칳mi jedni캜kami (v des칤tkov칠 soustav캩), kter칠 je d캩liteln칠 zadan칳m K. Jak se v캜as zastavit, kdy neexistuje? 	
- Najd캩te 캜칤slo mezi 1 a N s co nejv칤ce d캩liteli.	
- Vypo캜t캩te Eulerovu funkci (*Euler's totient function*) $\phi(n)$, kter치 je rovna po캜tu s $n$ nesoud캩ln칳ch (*relatively coprime*) 캜칤sel men코칤ch ne $n$.
